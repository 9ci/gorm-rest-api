
# Out of the box Restful API for grails. 

This is a library and [Grails] plugin to enhance [Gorm] to provide and expose a somewhat _opinionated_, ==well documented restful API== with intelligent out of the box defaults and minimal tweaking. It also keeps it easy to configure and customize on the fly at a deployed client site without the need to recompile.

While its somewhat opinionated it frames out Rest best practices outlined in the [Rest Design Principles] section.  It uses the [OpenAPI] spec (formerly [Swagger]) as well as how it maps the Gorm domains into that spec. Its accepts and returns only JSON and eschews the complexity of XML

While REST is not CRUD a lot of it really is. This project aims to makes it easy and quick to setup the common use cases that are really just CRUD Controller over the [GORM] domains so you can focus on the unique business logic use cases that are hard.

**Key features and goals of this plugin include:**

- **The simple stuff should be simple and automatic**
- DRY : Don't repeat yourself.
- Autogenerated code is evil. This includes tests
- Use AST, traits and tanspiling where possible 

---

- [ ] Near zero configuration to expose [Swagger] documented resources (the Gorm domains)
- [ ]  Rely on the domain's contraints as much as possible for configurations and docs.
- [ ]  Out of the box CRUD Controller modified from Grails [@Resource annotation and RestfulController](http://docs.grails.org/latest/guide/REST.html#domainResources) that can delegate to transactional Services (DAOs Repositories, Data Services) flavored services based on naming convention or configuration. Uses the [DAO] plugin by deafault for this.
- [ ]  Custom schema selects for retruned JSON fields that can be confiugured at runtime by a customer (does not require recompiling views)
- [ ]  Consistent documented use of HTTP status codes and headers
- [ ]  Uses [cache-headers](https://github.com/grails-plugins/cache-headers) for faster loading
- [ ]  Use [Services/DAO/Repository] pattern by defualt to keep the CRUD code in its own transactional service
- [ ]  Ability to 'query by POST' (to allow query criteria to be provided within the request body)
- [ ]  Intelligent defaults for security plugin with OATH and JWT.
- [ ]  Tools to ease GEB functional tests with Spock
- [ ]  Extensive regression tests


## Install

```groovy

```

  [OpenAPI]: https://github.com/OAI/OpenAPI-Specification
  [OAS]: https://github.com/OAI/OpenAPI-Specification
  [Swagger]: https://swagger.io/announcing-openapi-3-0/




## Notes right now

There are 3 ways to generate json.

1. using renderers, [Customizing Response Rendering](http://docs.grails.org/latest/guide/REST.html#renderers) 
2. using the [grails-views plugin](https://github.com/grails/grails-views/). 
3. using JSON.ObjectMarshaller which seems to be out of favor in the docs and is not longer mentioned
but remains in the grails-plugin-converter's main [JSON]. 
[this is a good overview](https://kylewbanks.com/blog/Customizing-JSON-Grails-Object-Marshalling) 

[JSON]: https://github.com/grails-plugins/grails-plugin-converters/blob/master/src/main/groovy/grails/converters/JSON.java

This [slide show](https://www.slideshare.net/clatimer/building-awesome-apis-in-grails) 
is a must preview does a good job of explaining the different options towards the end.

The goal is to provide the fastest way to render and object or collection
that allows custom includes or excludes. 

A `static includes = ...` can be set on the domain, the dao or the controller.
An gets overriden in that order. For example: if I set excludes on the domain 
if I set in on a Dao CRUD controller for that domain the it uses that. A setting
in the AppSetupConfig overides them all and a includes param sent into the endpoint 
will be used above all others. 
I would be nice to put the grails-views into this picture as well so that if there is a *.gson file
it gets used. Will need to figure out the resolution order. 

There is a way to register a name wigh JSON.createNamedConfig and then they can be used with `JSON.use(name){...}` 
This might be something we want to look into as an option as it may be really easy to incorporate our AppSetupConfig.


## Json rendering links

https://stackoverflow.com/questions/23940641/render-metadata-for-pagination-from-grails-restfulcontroller-index-search-action

Explains that is views/object/_object.gson is present then its not picking up ObjectMarshallers
https://stackoverflow.com/questions/43357469/grails-3-respond-method-doesnt-use-defined-json-marshaller-format
https://kylewbanks.com/blog/Customizing-JSON-Grails-Object-Marshalling

older 2.x plugin but has some good ideas.  
https://github.com/danveloper/grails-rest-renderers


include class and include version config options in the marshallers are exaplained a bit here
https://github.com/grails-plugins/grails-plugin-converters/commit/d7ef874a59e19abc03821181ff33e11f612c63a6

shows an example of pumping a pdf through the response.outputStream
http://grails.1312388.n4.nabble.com/Grails-REST-Web-Services-Using-custom-Renderer-to-render-PDF-td4654403.html

DefaultRendererRegistry in org.grails.plugins.web.rest.render is where the defaults
aer registered.




