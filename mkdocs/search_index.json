{
    "docs": [
        {
            "location": "/", 
            "text": "Overview\n\n\nThis is a library and plugin to enhance [Grails] and [Gorm] to provide and expose an \nopinionated\n, \nwell documented restful API\n with intelligent out of the box defaults and minimal tweaking. It is easy to configure and customize on the fly at a client site without the need to recompile.\n\n\n\n\nThe simple stuff should be simple and automatic\n\n\nDRY : Don't repeat yourself.\n\n\nAutogenerated code is evil. This includes tests\n\n\nTranspile where possible\n\n\n\n\nIts somewhat opinionated but frames out Rest best practices.  in that it uses the \nOpenAPI\n spec (formerly \nSwagger\n) as well as how it maps the Gorm domains into that spec. Its accepts and returns only JSON and eschews XML\n\n\nKey features of this plugin include:\n\n\n\n\n Near zero configuration to expose \nSwagger\n documented resources (the Gorm domains)\n\n\n Rely on the domain's contraints as much as possible for configurations and docs.\n\n\n Out of the box CRUD Controller modified from Grails \n@Resource annotation and RestfulController\n that can delegate to transactional DAO/repo falvored services based on naming convention or configuration. Uses the [DAO] plugin.\n\n\n Custom schema selects for retruned JSON fields that can be confiugured at runtime by a customer (does not require recompiling views)\n\n\n Consistent documented use of HTTP status codes and headers\n\n\n Used \ncache-headers\n\n\n Ability to 'query by POST' (to allow query criteria to be provided within the request body)\n\n\n Intelligent defaults for security plugin with OATH and JWT.\n\n\n Tools to ease GEB functional tests with Spock\n\n\n Extensive regression tests\n\n\n\n\nInstall\n\n\n\n\n\n\n\nrefs\n\n\nhttps://developer.fleetio.com/docs/errors", 
            "title": "Overview"
        }, 
        {
            "location": "/#overview", 
            "text": "This is a library and plugin to enhance [Grails] and [Gorm] to provide and expose an  opinionated ,  well documented restful API  with intelligent out of the box defaults and minimal tweaking. It is easy to configure and customize on the fly at a client site without the need to recompile.   The simple stuff should be simple and automatic  DRY : Don't repeat yourself.  Autogenerated code is evil. This includes tests  Transpile where possible   Its somewhat opinionated but frames out Rest best practices.  in that it uses the  OpenAPI  spec (formerly  Swagger ) as well as how it maps the Gorm domains into that spec. Its accepts and returns only JSON and eschews XML  Key features of this plugin include:    Near zero configuration to expose  Swagger  documented resources (the Gorm domains)   Rely on the domain's contraints as much as possible for configurations and docs.   Out of the box CRUD Controller modified from Grails  @Resource annotation and RestfulController  that can delegate to transactional DAO/repo falvored services based on naming convention or configuration. Uses the [DAO] plugin.   Custom schema selects for retruned JSON fields that can be confiugured at runtime by a customer (does not require recompiling views)   Consistent documented use of HTTP status codes and headers   Used  cache-headers   Ability to 'query by POST' (to allow query criteria to be provided within the request body)   Intelligent defaults for security plugin with OATH and JWT.   Tools to ease GEB functional tests with Spock   Extensive regression tests", 
            "title": "Overview"
        }, 
        {
            "location": "/#install", 
            "text": "", 
            "title": "Install"
        }, 
        {
            "location": "/#refs", 
            "text": "https://developer.fleetio.com/docs/errors", 
            "title": "refs"
        }, 
        {
            "location": "/design-principles/", 
            "text": "see:\n\nhttps://zalando.github.io/restful-api-guidelines/tooling/Tooling.html\n\n\nAPI as a Product\n\n\nWe are transforming to a platform comprising a rich set of products following a Software as a Platform (SaaS) model for our business partners. We want to deliver products to our customers which can be consumed like a service.\n\n\nPlatform products provide their functionality via (public) APIs; hence, the design of our APIs should be based on the API as a Product principle:\n\n\n\n\nTreat your API as product and understand the needs of its customers\n\n\nTake ownership and advocate for the customer and continuous improvement\n\n\nEmphasize easy understanding, discovery and usage of APIs; design APIs irresistible for client engineers\n\n\nActively improve and maintain API consistency over the long term\n\n\nMake use of customer feedback and provide service level support\n\n\nRESTful API as a Product makes the difference between enterprise integration business and agile, innovative product service business built on a platform of APIs.\n\n\nare easy to understand and learn\n\n\nare general and abstracted from specific implementation and use cases\n\n\nhave a common look and feel\n\n\nfollow a consistent RESTful style and syntax\n\n\n\n\nBased on your concrete customer use cases, you should carefully check the trade-offs of API design variants and avoid short-term server side implementation optimizations at the expense of unnecessary client side obligations and have a high attention on API quality and client developer experience.\n\n\nAPI as a Product is closely related to our API First principle (see next chapter) which is more focussed on how we engineer high quality APIs.\n\n\nAPI Design Principles\n\n\nREST is centered around business (data) entities exposed as resources that are identified via URIs and can be manipulated via standardized CRUD-like methods using different representations, self-descriptive messages and hypermedia. RESTful APIs tend to be less use-case specific and comes with less rigid client / server coupling and are more suitable as a platform interface being open for diverse client applications.\n\n\n\n\nWe prefer REST-based APIs with JSON payloads\n\n\nWe prefer systems to be truly RESTful\n\n\nWe apply the RESTful web service principles to all kind of application components, whether they provide functionality via the Internet or via the intranet as larger application elements.\n\n\nWe strive to build interoperating distributed systems that different teams can evolve in parallel.\n\n\n\n\nAn important principle for (RESTful) API design and usage is Postel's Law, aka the Robustness Principle\n\n\n\n\nBe liberal in what you accept, be conservative in what you send\n\n\n\n\nReadings: Read the following to gain additional insight on the RESTful service architecture paradigm and general RESTful API design style:\n\n\nSecurity\n\n\nTODO\n\n\nJSON Guidelines\n\n\nProperty Names\n\n\n\n\nbe consistent\n\n\nproperty names must be camelCase\n\n\nProperty names must be an ASCII subset. The first character must be a letter, an underscore or a dollar sign, and subsequent characters can be a letter, an underscore, hyphen or a number.\n\n\nArray and collection names should be pluralized\n\n\nUse Consistent Property Values\n\n\nBoolean property values must not be null and have a default, which means they are always shown but never required\n\n\n\n\nNull values should have their fields removed\n  Swagger/OpenAPI, which is in common use, doesn't support null field values (it does allow omitting that field completely if it is not marked as required). However that doesn't prevent clients and servers sending and receiving those fields with null values. Also, in some cases null may be a meaningful value - for example, JSON Merge Patch RFC 7382) using null to indicate property deletion.\n\n\n\n\n\n\nEmpty array values should not be null, they can be represented as the the empty list, [].\n\n\n\n\nEnumerations should be represented as Strings\n\n\nDate and date-time property values should conform to RFC 3399\n\n\nfor \"date\" use strings matching date-fullyear \"-\" date-month \"-\" date-mday, for example: 2015-05-28\n\n\nfor \"date-time\" use strings matching full-date \"T\" full-time, for example 2015-05-28T14:07:17Z\n\n\n\n\nA zone offset may be used (both, in request and responses) -- this is simply defined by the standards. However, we encourage restricting dates to UTC and without offsets. For example 2015-05-28T14:07:17Z rather than 2015-05-28T14:07:17+00:00. From experience we have learned that zone offsets are not easy to understand and often not correctly handled. Note also that zone offsets are different from local times that might be including daylight saving time. Localization of dates should be done by the services that provide user interfaces, if required.\n\n\n\n\n\n\nWhen it comes to storage, all dates should be consistently stored in UTC without a zone offset. Localization should be done locally by the services that provide user interfaces, if required.\n\n\n\n\n\n\nSchema based JSON properties that are by design durations and intervals could be strings formatted as recommended by ISO 8601 (Appendix A of RFC 3399 contains a grammar for durations).\n\n\n\n\n\n\nStandards should be used for Language, Country and Currency\n\n\n\n\n\n\nISO 3166-1-alpha2 country (It's \"GB\", not \"UK\",\nISO 639-1 language code\nBCP-47 (based on ISO 639-1) for language variants\nISO 4217 currency codes\n\n\nNaming\n\n\n\n\nUse lowercase separate words with hyphens for URI Path Segments\n\n\n\n\nExample:\n\n\n/shipment-orders/{shipment-order-id}\nThis applies to concrete path segments and not the names of path parameters. For example {shipment_order_id} would be ok as a path parameter.\n\n\nMust: Use snake_case (never camelCase) for Query Parameters\n\n\nExamples:\n\n\ncustomer_number, order_id, billing_address\nMust: Use Hyphenated HTTP Headers\n\n\nShould: Prefer Hyphenated-Pascal-Case for HTTP header Fields\n\n\nThis is for consistency in your documentation (most other headers follow this convention). Avoid camelCase (without hyphens). Exceptions are common abbreviations like \u201cID.\u201d\n\n\nExamples:\n\n\nAccept-Encoding\nApply-To-Redirect-Ref\nDisposition-Notification-Options\nOriginal-Message-ID\nSee also: HTTP Headers are case-insensitive (RFC 7230).\n\n\nMay: Use Standardized Headers\n\n\nUse this list and mention its support in your OpenAPI definition.\n\n\nMust: Pluralize Resource Names\n\n\nUsually, a collection of resource instances is provided (at least API should be ready here). The special case of a resource singleton is a collection with cardinality 1.\n\n\nMay: Use /api as first Path Segment\n\n\nIn most cases, all resources provided by a service are part of the public API, and therefore should be made available under the root \u201c/\u201d base path. If the service should also support non-public, internal APIs \u2014 for specific operational support functions, for example \u2014 add \u201c/api\u201d as base path to clearly separate public and non-public API resources.\n\n\nMust: Avoid Trailing Slashes\n\n\nThe trailing slash must not have specific semantics. Resource paths must deliver the same results whether they have the trailing slash or not.\n\n\nMay: Use Conventional Query Strings\n\n\nIf you provide query support for sorting, pagination, filtering functions or other actions, use the following standardized naming conventions:\n\n\nq \u2014 default query parameter (e.g. used by browser tab completion); should have an entity specific alias, like sku\nlimit \u2014 to restrict the number of entries. See Pagination section below. Hint: You can use size as an alternate query string.\ncursor \u2014 key-based page start. See Pagination section below.\noffset \u2014 numeric offset page start. See Pagination section below. Hint: In combination with limit, you can use page as an alternative to offset.\nsort \u2014 comma-separated list of fields to sort. To indicate sorting direction, fields my prefixed with + (ascending) or - (descending, default), e.g. /sales-orders?sort=+id\nfields \u2014 to retrieve a subset of fields. See Support Filtering of Resource Fields below.\nembed \u2014 to expand embedded entities (ie.: inside of an article entity, expand silhouette code into the silhouette object). Implementing \u201cexpand\u201d correctly is difficult, so do it with care. See Embedding resources for more details.\n\n\nsourced from  here\n\n\n\n\nNames and Verbs\nTo describe your resources, use concrete names and not action verbs.\nFor decades, computer scientists used action verbs in order to expose services in an RPC way, for instance:\ngetUser(1234) createUser(user) deleteAddress(1234)\n\n\nBy contrast, the RESTful approach is to use:\nGET /users/1234 POST /users (with JSON describing a user in the body) DELETE /addresses/1234\n\n\nURI case\nWhen it comes to naming resources in a program, there are 3 main types of case conventions: CamelCase, snake_case, and spinal-case. They are just a way of naming the resources to resemble natural language, while avoiding spaces, apostrophes and other exotic characters. This habit is universal in programming languages where only a finite set of characters is authorized for names.\n\n\nCamelCase\n\n\nCamelCase has been popularized by the Java language. It intends to emphasize the beginning of each word by making the first letter uppercase. E.g. camelCase, currentUser, etc. Aside from debates about its readability, its main drawback is to be ineffective in contexts which are not case sensitive.\n\n\nsnake_case\n\n\nsnakecase has been widely used for years by C programmers, and more recently in Ruby. Words are separated by underscores \u201c\u201d, thus letting a compiler or an interpreter understand it as a single symbol, but also allowing readers to separate words fluently. However, its popularity has decreased due to a lot of abuses in C programs with over-extended or too short names. Unlike camel case, there are very few contexts where snake case is not usable. Examples: snakecase, currentuser, etc.\n\n\nspinal-case\n\n\nspinal-case is a variant of snake case which uses hyphens \u201c-\u201d to separate words. The pros and cons are quite similar to those of snake case, with the exception that some languages do not allow hyphens in symbol names (for variable, class, or function naming). You may find it referred to as lisp-case because it is the usual way to name variables and functions in lisp dialects. It is also the traditional way of naming folders and files in UNIX and Linux systems. Examples: spinal-case, current-user, etc.\n\n\nAccording to RFC3986, URLs are \u201ccase sensitive\u201d (except for the scheme and the host).\nIn practice, though, a sensitive case may create dysfunctions with APIs hosted on a Windows system.", 
            "title": "Design Principles"
        }, 
        {
            "location": "/design-principles/#api-as-a-product", 
            "text": "We are transforming to a platform comprising a rich set of products following a Software as a Platform (SaaS) model for our business partners. We want to deliver products to our customers which can be consumed like a service.  Platform products provide their functionality via (public) APIs; hence, the design of our APIs should be based on the API as a Product principle:   Treat your API as product and understand the needs of its customers  Take ownership and advocate for the customer and continuous improvement  Emphasize easy understanding, discovery and usage of APIs; design APIs irresistible for client engineers  Actively improve and maintain API consistency over the long term  Make use of customer feedback and provide service level support  RESTful API as a Product makes the difference between enterprise integration business and agile, innovative product service business built on a platform of APIs.  are easy to understand and learn  are general and abstracted from specific implementation and use cases  have a common look and feel  follow a consistent RESTful style and syntax   Based on your concrete customer use cases, you should carefully check the trade-offs of API design variants and avoid short-term server side implementation optimizations at the expense of unnecessary client side obligations and have a high attention on API quality and client developer experience.  API as a Product is closely related to our API First principle (see next chapter) which is more focussed on how we engineer high quality APIs.", 
            "title": "API as a Product"
        }, 
        {
            "location": "/design-principles/#api-design-principles", 
            "text": "REST is centered around business (data) entities exposed as resources that are identified via URIs and can be manipulated via standardized CRUD-like methods using different representations, self-descriptive messages and hypermedia. RESTful APIs tend to be less use-case specific and comes with less rigid client / server coupling and are more suitable as a platform interface being open for diverse client applications.   We prefer REST-based APIs with JSON payloads  We prefer systems to be truly RESTful  We apply the RESTful web service principles to all kind of application components, whether they provide functionality via the Internet or via the intranet as larger application elements.  We strive to build interoperating distributed systems that different teams can evolve in parallel.   An important principle for (RESTful) API design and usage is Postel's Law, aka the Robustness Principle   Be liberal in what you accept, be conservative in what you send   Readings: Read the following to gain additional insight on the RESTful service architecture paradigm and general RESTful API design style:", 
            "title": "API Design Principles"
        }, 
        {
            "location": "/design-principles/#security", 
            "text": "TODO", 
            "title": "Security"
        }, 
        {
            "location": "/design-principles/#json-guidelines", 
            "text": "", 
            "title": "JSON Guidelines"
        }, 
        {
            "location": "/design-principles/#property-names", 
            "text": "be consistent  property names must be camelCase  Property names must be an ASCII subset. The first character must be a letter, an underscore or a dollar sign, and subsequent characters can be a letter, an underscore, hyphen or a number.  Array and collection names should be pluralized  Use Consistent Property Values  Boolean property values must not be null and have a default, which means they are always shown but never required   Null values should have their fields removed\n  Swagger/OpenAPI, which is in common use, doesn't support null field values (it does allow omitting that field completely if it is not marked as required). However that doesn't prevent clients and servers sending and receiving those fields with null values. Also, in some cases null may be a meaningful value - for example, JSON Merge Patch RFC 7382) using null to indicate property deletion.    Empty array values should not be null, they can be represented as the the empty list, [].   Enumerations should be represented as Strings  Date and date-time property values should conform to RFC 3399  for \"date\" use strings matching date-fullyear \"-\" date-month \"-\" date-mday, for example: 2015-05-28  for \"date-time\" use strings matching full-date \"T\" full-time, for example 2015-05-28T14:07:17Z   A zone offset may be used (both, in request and responses) -- this is simply defined by the standards. However, we encourage restricting dates to UTC and without offsets. For example 2015-05-28T14:07:17Z rather than 2015-05-28T14:07:17+00:00. From experience we have learned that zone offsets are not easy to understand and often not correctly handled. Note also that zone offsets are different from local times that might be including daylight saving time. Localization of dates should be done by the services that provide user interfaces, if required.    When it comes to storage, all dates should be consistently stored in UTC without a zone offset. Localization should be done locally by the services that provide user interfaces, if required.    Schema based JSON properties that are by design durations and intervals could be strings formatted as recommended by ISO 8601 (Appendix A of RFC 3399 contains a grammar for durations).    Standards should be used for Language, Country and Currency    ISO 3166-1-alpha2 country (It's \"GB\", not \"UK\",\nISO 639-1 language code\nBCP-47 (based on ISO 639-1) for language variants\nISO 4217 currency codes", 
            "title": "Property Names"
        }, 
        {
            "location": "/design-principles/#naming", 
            "text": "Use lowercase separate words with hyphens for URI Path Segments   Example:  /shipment-orders/{shipment-order-id}\nThis applies to concrete path segments and not the names of path parameters. For example {shipment_order_id} would be ok as a path parameter.  Must: Use snake_case (never camelCase) for Query Parameters  Examples:  customer_number, order_id, billing_address\nMust: Use Hyphenated HTTP Headers  Should: Prefer Hyphenated-Pascal-Case for HTTP header Fields  This is for consistency in your documentation (most other headers follow this convention). Avoid camelCase (without hyphens). Exceptions are common abbreviations like \u201cID.\u201d  Examples:  Accept-Encoding\nApply-To-Redirect-Ref\nDisposition-Notification-Options\nOriginal-Message-ID\nSee also: HTTP Headers are case-insensitive (RFC 7230).  May: Use Standardized Headers  Use this list and mention its support in your OpenAPI definition.  Must: Pluralize Resource Names  Usually, a collection of resource instances is provided (at least API should be ready here). The special case of a resource singleton is a collection with cardinality 1.  May: Use /api as first Path Segment  In most cases, all resources provided by a service are part of the public API, and therefore should be made available under the root \u201c/\u201d base path. If the service should also support non-public, internal APIs \u2014 for specific operational support functions, for example \u2014 add \u201c/api\u201d as base path to clearly separate public and non-public API resources.  Must: Avoid Trailing Slashes  The trailing slash must not have specific semantics. Resource paths must deliver the same results whether they have the trailing slash or not.  May: Use Conventional Query Strings  If you provide query support for sorting, pagination, filtering functions or other actions, use the following standardized naming conventions:  q \u2014 default query parameter (e.g. used by browser tab completion); should have an entity specific alias, like sku\nlimit \u2014 to restrict the number of entries. See Pagination section below. Hint: You can use size as an alternate query string.\ncursor \u2014 key-based page start. See Pagination section below.\noffset \u2014 numeric offset page start. See Pagination section below. Hint: In combination with limit, you can use page as an alternative to offset.\nsort \u2014 comma-separated list of fields to sort. To indicate sorting direction, fields my prefixed with + (ascending) or - (descending, default), e.g. /sales-orders?sort=+id\nfields \u2014 to retrieve a subset of fields. See Support Filtering of Resource Fields below.\nembed \u2014 to expand embedded entities (ie.: inside of an article entity, expand silhouette code into the silhouette object). Implementing \u201cexpand\u201d correctly is difficult, so do it with care. See Embedding resources for more details.  sourced from  here   Names and Verbs\nTo describe your resources, use concrete names and not action verbs.\nFor decades, computer scientists used action verbs in order to expose services in an RPC way, for instance:\ngetUser(1234) createUser(user) deleteAddress(1234)  By contrast, the RESTful approach is to use:\nGET /users/1234 POST /users (with JSON describing a user in the body) DELETE /addresses/1234  URI case\nWhen it comes to naming resources in a program, there are 3 main types of case conventions: CamelCase, snake_case, and spinal-case. They are just a way of naming the resources to resemble natural language, while avoiding spaces, apostrophes and other exotic characters. This habit is universal in programming languages where only a finite set of characters is authorized for names.  CamelCase  CamelCase has been popularized by the Java language. It intends to emphasize the beginning of each word by making the first letter uppercase. E.g. camelCase, currentUser, etc. Aside from debates about its readability, its main drawback is to be ineffective in contexts which are not case sensitive.  snake_case  snakecase has been widely used for years by C programmers, and more recently in Ruby. Words are separated by underscores \u201c\u201d, thus letting a compiler or an interpreter understand it as a single symbol, but also allowing readers to separate words fluently. However, its popularity has decreased due to a lot of abuses in C programs with over-extended or too short names. Unlike camel case, there are very few contexts where snake case is not usable. Examples: snakecase, currentuser, etc.  spinal-case  spinal-case is a variant of snake case which uses hyphens \u201c-\u201d to separate words. The pros and cons are quite similar to those of snake case, with the exception that some languages do not allow hyphens in symbol names (for variable, class, or function naming). You may find it referred to as lisp-case because it is the usual way to name variables and functions in lisp dialects. It is also the traditional way of naming folders and files in UNIX and Linux systems. Examples: spinal-case, current-user, etc.  According to RFC3986, URLs are \u201ccase sensitive\u201d (except for the scheme and the host).\nIn practice, though, a sensitive case may create dysfunctions with APIs hosted on a Windows system.", 
            "title": "Naming"
        }, 
        {
            "location": "/api-docs-template/", 
            "text": "This can be used as a template to start a good intro to a products API docs\n\n\nReference\n\n\nThe API is organized around REST. The API has predictable, resource-oriented URLs, and uses HTTP response codes to indicate API errors. We use built-in HTTP features, like HTTP authentication and HTTP verbs, which are understood by off-the-shelf HTTP clients. We support cross-origin resource sharing, allowing you to interact securely with our API from a client-side web application (though you should never expose your secret API key in any public website's client-side code). JSON is returned by all API responses, including errors.\nTo make an API as explorable as possible, users can have test mode and live mode API keys. There is no \"switch\" for changing between modes, just use the appropriate key to perform a live or test transaction. Requests made with test mode credentials never hit production\n\n\nAn operation is a unit of a REST API that you can call. An operation comprises an HTTP verb and a URL path that is subordinate to the context root of the API. By configuring the operation, you define how the API is exposed to your developers.\n\n\nAuthentication\n\n\nTODO\n\n\nSchema\n\n\nHTTP Verbs\n\n\nThe URLs are expected to following normal REST conventions.\n\n\n\n\n\n\n\n\nHTTP Method\n\n\nCtrl Action\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\nGET\n\n\nindex\n\n\nRead a resource or list of resources\n\n\n\n\n\n\nPOST\n\n\nupdate\n\n\nCreate a new resource (when the key is not known a-priori) See note.\n\n\n\n\n\n\nPUT\n\n\nsave\n\n\nUpdate an existing resource or create one if the key is pre-defined\n\n\n\n\n\n\nDELETE\n\n\nRemove\n\n\nRemove a resource\n\n\n\n\n\n\n\n\nENDPOINTS AND ACTIONS\n\n\n\n\n\n\n\n\nEndpoint\n\n\nAction\n\n\nHTTP Verbs\n\n\nReturns\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n/thing\n\n\nlist(params)\n\n\nGET\n\n\nArray - or a paginated array of things\n\n\n200\n\n\n\n\n\n\n/thing/123\n\n\nshow(id)\n\n\nGET\n\n\nObject - \n  the thing corresponding to the id param\n\n\n200\n\n\n\n\n\n\n/thing\n\n\ninsert(body)\n\n\nPOST\n\n\nObject - \n Inserts a new thing and returns it\n\n\n201\n\n\n\n\n\n\n/thing/123\n\n\nupdate(id, body)\n\n\nPUT\n\n\nObject - \n  the thing corresponding to the id param\n\n\n200\n\n\n\n\n\n\n/thing/123\n\n\ndelete(id)\n\n\nDELETE\n\n\nnothing \n  Deletes the thing corresponding to the id param\n\n\n204\n\n\n\n\n\n\n\n\n\n\nPATCH\n\n\nTODO\n\n\n200\n\n\n\n\n\n\n\n\nIdempotent Requests\n\n\nThe API supports \nidempotency\n for safely retrying requests without accidentally performing the same operation twice. For example, if a request to create a doodad fails due to a network connection error, you can retry the request with the same idempotency key to guarantee that only a single charge is created.\nGET and DELETE requests are idempotent by definition, meaning that the same backend work will occur no matter how many times the same request is issued. You shouldn't send an idempotency key with these verbs because it will have no effect.\nTo perform an idempotent request, provide an additional \nIdempotency-Key: \nkey\n header to the request.\n\n\nresponses\n\n\nSuccess Status Codes\n\n\n\n\n\n\n\n\nStatus Code\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n200 - OK\n\n\nEverything worked as expected. default\n\n\n\n\n\n\n201 - CREATED\n\n\nResource/instance was created. returned from \nsave\n action\n\n\n\n\n\n\n204 - NO_CONTENT\n\n\nresponse code on successful DELETE request\n\n\n\n\n\n\n404 - NOT_FOUND\n\n\nThe requested resource doesn't exist.\n\n\n\n\n\n\n422\n\n\nValidation errors.\n\n\n\n\n\n\n405 - METHOD_NOT_ALLOWED\n\n\nIf method (GET,POST,etc..) is not setup in \nstatic allowedMethods\n for action or resource is read only\n\n\n\n\n\n\n406 - NOT_ACCEPTABLE\n\n\nAccept header requests a response in an unsupported format. not configed in mime-types. RestResponder uses this\n\n\n\n\n\n\n\n\nResponse Body.\n\n\nAny response body will be one of the following:\n\n\n\n\nA representation of a resource\n\n\nAn array of representations of a resource (either a JSON array, or list representation in xml)\n\n\nan empty body\n\n\n\n\nAny 'envelope' information is conveyed in headers.\n\n\nPagination\n\n\nBecause large data sets are possible, paging is used for all GET index actions.\nThe default page size is set to 100. 9ci will return four response headers along with the result set.\n\n\n\n\n\n\n\n\nHeader\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nX-Pagination-Limit\n\n\nThe per page size limit. Defaults to 100\n\n\n\n\n\n\nX-Pagination-Current-Page\n\n\nThe current page. Defaults to 1.\n\n\n\n\n\n\nX-Pagination-Total-Pages\n\n\nThe total number of pages in the result list.\n\n\n\n\n\n\nX-Pagination-Total-Count\n\n\nThe total number of items across all pages.\n\n\n\n\n\n\n\n\nTo retrieve data for a specific page, simply specify the page query parameter \n/doodad?page=5\n.\n\n\n\n\n\n\n\n\nQuery parameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npage\n\n\nThe page number to show\n\n\n\n\n\n\nlimit or max\n\n\nThe number of items in the result list to show per page\n\n\n\n\n\n\noffset\n\n\nThe item number to start from (zero based) in the result list. Don't use both this and page\n\n\n\n\n\n\n\n\nPages start at 1 of course. Any value less than 1 will default to the first page while any value greater than Pagination-Total-Pages will simply return an empty result set.\n\n\nErrors\n\n\nErrors come in the form of HTTP response codes to indicate the success or failure of an API request. as listed as well as validation errors\n\n\nNot all errors map cleanly onto HTTP response codes, however. When a request is valid but does not complete successfully (e.g., a card is declined), we return a 422 error code.\n\n\n\n\n\n\n\n\nStatus Code\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n422 - UNPROCESSABLE_ENTITY\n\n\nValidation errors.\n\n\n\n\n\n\n404 - NOT_FOUND\n\n\nThe requested resource doesn't exist.\n\n\n\n\n\n\n405 - METHOD_NOT_ALLOWED\n\n\nIf method (GET,POST,etc..) is not setup in \nstatic allowedMethods\n for action or resource is read only\n\n\n\n\n\n\n406 - NOT_ACCEPTABLE\n\n\nAccept header requests a response in an unsupported format. not configed in mime-types. RestResponder uses this\n\n\n\n\n\n\n\n\nValidation Errors 422\n\n\nIf you try to create or update a record with invalid data, you'll receive a 422 response code and the operation will fail.\n\n\nYou'll also receive an errors object in the response body with the resulting error messages. This object will have one key for each field with errors.\n\n\nEach field will have an array of human readable error messages, as show below:\n\nTODO", 
            "title": "Docs Template"
        }, 
        {
            "location": "/api-docs-template/#reference", 
            "text": "The API is organized around REST. The API has predictable, resource-oriented URLs, and uses HTTP response codes to indicate API errors. We use built-in HTTP features, like HTTP authentication and HTTP verbs, which are understood by off-the-shelf HTTP clients. We support cross-origin resource sharing, allowing you to interact securely with our API from a client-side web application (though you should never expose your secret API key in any public website's client-side code). JSON is returned by all API responses, including errors.\nTo make an API as explorable as possible, users can have test mode and live mode API keys. There is no \"switch\" for changing between modes, just use the appropriate key to perform a live or test transaction. Requests made with test mode credentials never hit production  An operation is a unit of a REST API that you can call. An operation comprises an HTTP verb and a URL path that is subordinate to the context root of the API. By configuring the operation, you define how the API is exposed to your developers.", 
            "title": "Reference"
        }, 
        {
            "location": "/api-docs-template/#authentication", 
            "text": "TODO", 
            "title": "Authentication"
        }, 
        {
            "location": "/api-docs-template/#schema", 
            "text": "", 
            "title": "Schema"
        }, 
        {
            "location": "/api-docs-template/#http-verbs", 
            "text": "The URLs are expected to following normal REST conventions.     HTTP Method  Ctrl Action  Purpose      GET  index  Read a resource or list of resources    POST  update  Create a new resource (when the key is not known a-priori) See note.    PUT  save  Update an existing resource or create one if the key is pre-defined    DELETE  Remove  Remove a resource", 
            "title": "HTTP Verbs"
        }, 
        {
            "location": "/api-docs-template/#endpoints-and-actions", 
            "text": "Endpoint  Action  HTTP Verbs  Returns  code      /thing  list(params)  GET  Array - or a paginated array of things  200    /thing/123  show(id)  GET  Object -    the thing corresponding to the id param  200    /thing  insert(body)  POST  Object -   Inserts a new thing and returns it  201    /thing/123  update(id, body)  PUT  Object -    the thing corresponding to the id param  200    /thing/123  delete(id)  DELETE  nothing    Deletes the thing corresponding to the id param  204      PATCH  TODO  200", 
            "title": "ENDPOINTS AND ACTIONS"
        }, 
        {
            "location": "/api-docs-template/#idempotent-requests", 
            "text": "The API supports  idempotency  for safely retrying requests without accidentally performing the same operation twice. For example, if a request to create a doodad fails due to a network connection error, you can retry the request with the same idempotency key to guarantee that only a single charge is created.\nGET and DELETE requests are idempotent by definition, meaning that the same backend work will occur no matter how many times the same request is issued. You shouldn't send an idempotency key with these verbs because it will have no effect.\nTo perform an idempotent request, provide an additional  Idempotency-Key:  key  header to the request.", 
            "title": "Idempotent Requests"
        }, 
        {
            "location": "/api-docs-template/#responses", 
            "text": "", 
            "title": "responses"
        }, 
        {
            "location": "/api-docs-template/#success-status-codes", 
            "text": "Status Code  Description      200 - OK  Everything worked as expected. default    201 - CREATED  Resource/instance was created. returned from  save  action    204 - NO_CONTENT  response code on successful DELETE request    404 - NOT_FOUND  The requested resource doesn't exist.    422  Validation errors.    405 - METHOD_NOT_ALLOWED  If method (GET,POST,etc..) is not setup in  static allowedMethods  for action or resource is read only    406 - NOT_ACCEPTABLE  Accept header requests a response in an unsupported format. not configed in mime-types. RestResponder uses this", 
            "title": "Success Status Codes"
        }, 
        {
            "location": "/api-docs-template/#response-body", 
            "text": "Any response body will be one of the following:   A representation of a resource  An array of representations of a resource (either a JSON array, or list representation in xml)  an empty body   Any 'envelope' information is conveyed in headers.", 
            "title": "Response Body."
        }, 
        {
            "location": "/api-docs-template/#pagination", 
            "text": "Because large data sets are possible, paging is used for all GET index actions.\nThe default page size is set to 100. 9ci will return four response headers along with the result set.     Header  Description      X-Pagination-Limit  The per page size limit. Defaults to 100    X-Pagination-Current-Page  The current page. Defaults to 1.    X-Pagination-Total-Pages  The total number of pages in the result list.    X-Pagination-Total-Count  The total number of items across all pages.     To retrieve data for a specific page, simply specify the page query parameter  /doodad?page=5 .     Query parameters  Description      page  The page number to show    limit or max  The number of items in the result list to show per page    offset  The item number to start from (zero based) in the result list. Don't use both this and page     Pages start at 1 of course. Any value less than 1 will default to the first page while any value greater than Pagination-Total-Pages will simply return an empty result set.", 
            "title": "Pagination"
        }, 
        {
            "location": "/api-docs-template/#errors", 
            "text": "Errors come in the form of HTTP response codes to indicate the success or failure of an API request. as listed as well as validation errors  Not all errors map cleanly onto HTTP response codes, however. When a request is valid but does not complete successfully (e.g., a card is declined), we return a 422 error code.     Status Code  Description      422 - UNPROCESSABLE_ENTITY  Validation errors.    404 - NOT_FOUND  The requested resource doesn't exist.    405 - METHOD_NOT_ALLOWED  If method (GET,POST,etc..) is not setup in  static allowedMethods  for action or resource is read only    406 - NOT_ACCEPTABLE  Accept header requests a response in an unsupported format. not configed in mime-types. RestResponder uses this", 
            "title": "Errors"
        }, 
        {
            "location": "/api-docs-template/#validation-errors-422", 
            "text": "If you try to create or update a record with invalid data, you'll receive a 422 response code and the operation will fail.  You'll also receive an errors object in the response body with the resulting error messages. This object will have one key for each field with errors.  Each field will have an array of human readable error messages, as show below: TODO", 
            "title": "Validation Errors 422"
        }, 
        {
            "location": "/swagger-openapi/", 
            "text": "OpenAPI Specification (OAS)\n\n\n\n\nThe \nOpenAPI\n Specification (OAS) defines a standard, language-agnostic interface to RESTful APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection.\n\n\n\n\nOAS\n formerly known as \nSwagger\n and they donated it to the Linux Foundation to become OpenAPI (Swagger is a better name) . Swagger was version 2.0 and current version of \nOAS\n is 3.0. \n\n\nOAS is a super set of \njson-schema\n. In Grails or Spring, OAS describes both the controllers and actions as well the domains. Its uses \njson-schema\n, particularly the validation spec to describe the domains. \n\n\n\n\n See \nhere for an example\n of the Swagger 2.0 spec in action.\n\n\n\n\nGoals\n\n\nThere are 2 primary goals of getting OAS and json-schema setup for our Grails Gorm domains\n\n\n\n\nEnable automatic generation of forms with something like \nSchema Form\n\n\nAutogenerate docs like some of the examples links below\n\n\n\n\njson-schema docs, specs and examples\n\n\n\n\n \n\n\n\n\njson-schema\n\n\njson-schema example\n\n\njson-schema Spec\n\n\njson-schema Validation Spec\n\n\nExamples\n \n\n\nspacetelescope has a \nDecent guide\n\n\nAnother \nexample\n of what we are after\n\n\n\n\n\n\nOther Articles \n Tutorials\n\n\nhttps://brandur.org/elegant-apis\n\n\nhttps://blog.cloudflare.com/cloudflares-json-powered-documentation-generator/\n\n\nSwagger\n\n\nSwagger is a superset of json-schema. See \nhttp://editor.swagger.io/#/\n for an example\nAnd the Swagger site for plenty of examples\n\n\nDoc Engines\n\n\nIf we have our API defined in Swagger and/or json-schema or yml then we can use something like \n\nhttps://github.com/mermade/widdershins\n to generate a slate based doc site\nSee \nhttp://mikeralphson.github.io/openapi/2016/12/19/oa2s-comparison\n \nExample site \nhttps://mermade.github.io/shins/#swagger-petstore-v1-0-0\n \n\n\nAs mentioned in widdershins if we are using a message queue then this is worth looking at for \n\n\nOther Resources\n\n\nVueJs\n\n\nhttps://github.com/koumoul-dev/vue-openapi\n\n\nhttps://github.com/koumoul-dev/openapi-viewer\n\n\nExamples\n\n\nhttp://swapi.co/\n\n\nhttps://projects.spring.io/spring-restdocs/\n\n\nJava version of schema validator\n\nhttps://github.com/java-json-tools/json-schema-validator\n\n\njavadoc to markdown\n\n\nhttps://delight-im.github.io/Javadoc-to-Markdown/\n\n\nUsing javadocs or annotations\n\n\nThese are some possibilities to generate swagger or docs from javadocs ideally\n\nhttps://wiki.onosproject.org/display/ONOS/Generating+Swagger+documentation+for+the+REST+API\n\n\nThis provides a pretty good overview of 4 options. Swagger(spring fox), Spring REST Docs, RAML, ApiDocJS\n\nhttps://opencredo.com/rest-api-tooling-review/\n and Spring Fox looks promising \nhttp://springfox.github.io/springfox/docs/current/\n there seems to be a version for Grails too, \nhttps://github.com/springfox/springfox-grails-integration", 
            "title": "OpenAPI - Swagger"
        }, 
        {
            "location": "/swagger-openapi/#openapi-specification-oas", 
            "text": "The  OpenAPI  Specification (OAS) defines a standard, language-agnostic interface to RESTful APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection.   OAS  formerly known as  Swagger  and they donated it to the Linux Foundation to become OpenAPI (Swagger is a better name) . Swagger was version 2.0 and current version of  OAS  is 3.0.   OAS is a super set of  json-schema . In Grails or Spring, OAS describes both the controllers and actions as well the domains. Its uses  json-schema , particularly the validation spec to describe the domains.     See  here for an example  of the Swagger 2.0 spec in action.", 
            "title": "OpenAPI Specification (OAS)"
        }, 
        {
            "location": "/swagger-openapi/#goals", 
            "text": "There are 2 primary goals of getting OAS and json-schema setup for our Grails Gorm domains   Enable automatic generation of forms with something like  Schema Form  Autogenerate docs like some of the examples links below", 
            "title": "Goals"
        }, 
        {
            "location": "/swagger-openapi/#json-schema-docs-specs-and-examples", 
            "text": "json-schema  json-schema example  json-schema Spec  json-schema Validation Spec  Examples    spacetelescope has a  Decent guide  Another  example  of what we are after", 
            "title": "json-schema docs, specs and examples"
        }, 
        {
            "location": "/swagger-openapi/#other-articles-tutorials", 
            "text": "https://brandur.org/elegant-apis  https://blog.cloudflare.com/cloudflares-json-powered-documentation-generator/", 
            "title": "Other Articles &amp; Tutorials"
        }, 
        {
            "location": "/swagger-openapi/#swagger", 
            "text": "Swagger is a superset of json-schema. See  http://editor.swagger.io/#/  for an example\nAnd the Swagger site for plenty of examples", 
            "title": "Swagger"
        }, 
        {
            "location": "/swagger-openapi/#doc-engines", 
            "text": "If we have our API defined in Swagger and/or json-schema or yml then we can use something like  https://github.com/mermade/widdershins  to generate a slate based doc site\nSee  http://mikeralphson.github.io/openapi/2016/12/19/oa2s-comparison  \nExample site  https://mermade.github.io/shins/#swagger-petstore-v1-0-0    As mentioned in widdershins if we are using a message queue then this is worth looking at for", 
            "title": "Doc Engines"
        }, 
        {
            "location": "/swagger-openapi/#other-resources", 
            "text": "", 
            "title": "Other Resources"
        }, 
        {
            "location": "/swagger-openapi/#vuejs", 
            "text": "https://github.com/koumoul-dev/vue-openapi  https://github.com/koumoul-dev/openapi-viewer", 
            "title": "VueJs"
        }, 
        {
            "location": "/swagger-openapi/#examples", 
            "text": "http://swapi.co/  https://projects.spring.io/spring-restdocs/  Java version of schema validator https://github.com/java-json-tools/json-schema-validator", 
            "title": "Examples"
        }, 
        {
            "location": "/swagger-openapi/#javadoc-to-markdown", 
            "text": "https://delight-im.github.io/Javadoc-to-Markdown/", 
            "title": "javadoc to markdown"
        }, 
        {
            "location": "/swagger-openapi/#using-javadocs-or-annotations", 
            "text": "These are some possibilities to generate swagger or docs from javadocs ideally https://wiki.onosproject.org/display/ONOS/Generating+Swagger+documentation+for+the+REST+API  This provides a pretty good overview of 4 options. Swagger(spring fox), Spring REST Docs, RAML, ApiDocJS https://opencredo.com/rest-api-tooling-review/  and Spring Fox looks promising  http://springfox.github.io/springfox/docs/current/  there seems to be a version for Grails too,  https://github.com/springfox/springfox-grails-integration", 
            "title": "Using javadocs or annotations"
        }, 
        {
            "location": "/tutorial/stock/", 
            "text": "Getting started\n\n\nFor this tutorial you will need\n\n\n\n\n\n\nJDK (I advise 8, but you can take 7 as well).\n\n\n\n\n\n\nGit.\n\n\n\n\n\n\nGrails 3.2.11 (you can install it with \nhttp://sdkman.io\n on most Unix based systems.)\n\n\n\n\n\n\nAfter all is installed clone the repo:\n\n\ngit clone https://github.com/9ci/angle-grinder\n\n\n\n\nand switch to branch \nrest_tutorial\n branch, and go to \nangle-grinder/grails/restTutorial\n, the final result is in\nthe \nsnapshot\n folder for each step\n\n\nSo first let's create new grails app:\n\n\n$ grails create-app -profile rest-api -features hibernate4 resttutorail\nApplication created at angle-grinder/grails/restTutorial\n\n\n\n\nGrails 3 provides several different profiles you can read about them in the \ngrails docs\n\n\nCreating an API with Grails Web Services\n\n\nAs described in the \ngrails ws docs\n\nwe will use the default out of the box functionality as a starting point.\n\n\nCreating a GORM domain\n\n\ngrails create-domain-class Contact\n\n\n\n\nThen set it up like so:\n\n\nContact.groovy\n\n\npackage\n \nresttutorial\n\n\n\nclass\n \nContact\n \n{\n\n  \nString\n \nfirstName\n\n  \nString\n \nlastName\n\n  \nString\n \nemail\n\n  \nBoolean\n \ninactive\n\n\n  \nstatic\n \nconstraints\n \n=\n \n{\n\n    \nfirstName\n \nnullable:\n \nfalse\n\n    \ninactive\n \nbindable:\n \nfalse\n\n  \n}\n\n\n}\n\n\n\n\nTo avoid writing \nnullable: true\n we will set the default to allow nulls for fields\nAdd the following to \ngrails-app/conf/application.groovy\n\n\napplication.groovy\n\n\ngrails\n.\ngorm\n.\ndefault\n.\nconstraints\n \n=\n \n{\n\n  \n*\n \n(\nnullable:\n \ntrue\n,\n \nblank:\n \ntrue\n)\n\n\n}\n\n\n\n\nWe will load 100 rows of mock test data from a file \nContacts.json\n in resources.\nThe mock data was generated from a great tool \nhttps://www.mockaroo.com\n\n\nAdd the following code to \ngrails-app/init/BootStrap.groovy\n\n\nBootStrap.groovy\n\n\npackage\n \nresttutorial\n\n\n\nimport\n \ngroovy.json.JsonSlurper\n\n\n\nclass\n \nBootStrap\n \n{\n\n    \ndef\n \ngrailsApplication\n\n    \ndef\n \ninit\n \n=\n \n{\n \nservletContext\n \n-\n\n        \ndef\n \ndata\n \n=\n \nnew\n \nJsonSlurper\n().\nparse\n(\nnew\n \nFile\n(\n../resources/Contacts.json\n))\n\n        \ndata\n.\neach\n{\n\n          \nContact\n \ncontact\n \n=\n \nnew\n \nContact\n(\nit\n)\n\n          \ncontact\n.\nsave\n(\nfailOnError:\ntrue\n,\nflush:\n \ntrue\n)\n\n        \n}\n\n    \n}\n\n    \ndef\n \ndestroy\n \n=\n \n{\n\n    \n}\n\n\n}\n\n\n\n\nAdding the \n@Resource\n annotation to our domain\n\n\n:url-dr: {docs-grails}#domainResources\n\n\nSo now we can start working on creating REST Api for our app.\nThe easiest way is to use {url-dr}[domain resources].\nSo as we see from {url-dr}[docs] we just need to update our domain a bit (just add {docs-grails-api}/grails/rest/Resource.html[@Resource] anotation) in such a way:\n\n\nContact.groovy\n\n\nimport\n \ngrails.rest.Resource\n\n\n\n@Resource\n(\nuri\n \n=\n \n/contact\n,\n \nformats\n \n=\n \n[\njson\n])\n\n\nclass\n \nContact\n \n{\n\n  \n...\n\n\n}\n\n\n\n\n\n\n:memo \nOn plural resource names\n\nAs you will notice we did not pluralize it to contacts above as many will do.\nWe are aware of the debate on this in the rest world. We feel this will cause confusion down the line to do it.\n\n\n\n\nEnglish plural rules like \"cherry/cherries\" or \"goose/geese/moose/meese\" are not the nicest thing to think of while developing API, particularly when english is not your mother tongue.\n\n\nMany times, as in Grails, we want to generate endpoint from the model, which is usually singular. It does not play nicely with the above pluralization exceptions and creates more work maintaining UrlMappings.\n\n\nWhen the model is singular, which is normally is for us, keeping the rest endpoint singular will have the rest developers and the grails developers speaking the same language\n\n\nThe argument \"usually you start querying by a Get to display a list\" does not refer to any real use case. And we will end up querying single items as much as and even more than a list of items.\n\n\n\n\n\n\nThe \nRestfullController\n\n\n@Resource\n creates a RestfullController for the domain\n\n\n\n\n \nThe \n@Resource\n annotation\n\nis used in an ASTTransformation that creates a controller that extends RestfullController. See \nResourceTransform\n for details on how it does this. Later we will show how to specify the controller to user with superClass property.\n\n\n\n\nDefault Endpoints and Status Codes\n\n\nUrl Mappings\n\n\nThe \nExtending Restful Controllers\n section of the \ngrails docs\n outlines the action names and the URIs they map to:\n\n\n.URI, Controller Action and Response Defaults\n[cols=\"2,1,1,3\", format=\"csv\", options=\"header\", width=\"80\",grid=rows]\n|===\nURI, Method, Action, Response Data\n/contact , GET , index , Paged List\n/contact/create, GET , create , Contact.newInstance() unsaved\n/contact, POST , save , The successfully saved contact (same as show's get)\n/contact/\n\\({id}, GET , show , The contact for the id\n/contact/\\)\n/edit, GET , edit , The contact for the id. same as show\n/contact/\n\\({id}, PUT , update , The successfully updated contact\n/contact/\\)\n, DELETE , delete , Empty response with HTTP status code 204\n|===\n\n\n==== Status Code Defaults\n\n\nPiecing together the {docs-HttpStatus}[HttpStatus codes] and results from RestfullController, RestResponder and _errors.gson,\nthese are what looks like the out of the box status codes as of Grails 3.2.2\n\n\n.Status Codes Out Of Box\n[options=\"header\", cols=\"1,2\", grid=rows]\n|===\n| Status Code               | Description\n| 200 - OK                  | Everything worked as expected. default\n| 201 - CREATED             | Resource/instance was created. returned from \nsave\n action\n| 204 - NO_CONTENT          | response code on successful DELETE request\n| 404 - NOT_FOUND           | The requested resource doesn't exist.\n| 405 - METHOD_NOT_ALLOWED  | If method (GET,POST,etc..) is not setup in \nstatic allowedMethods\n for action or resource is read only\n| 406 - NOT_ACCEPTABLE      | Accept header requests a response in an unsupported format. not configed in mime-types. RestResponder uses this\n| 422 - UNPROCESSABLE_ENTITY | Validation errors.\n|===\n\n\n=== API Namespace\n\n\nA Namespace is a mechanism to partition resources into a logically named group.\n\n\nSo the controllers that response for the REST endpoints we will move to separate namespace to avoid cases when we need to\nhave Controllers for GSP rendering or some other not related to REST stuff.\n\n\nAs a our preferred namespace design we will use the \"api\" namespace prefix for the rest of the tutorial.\nSo we will add \nnamespace = 'api'\n on the contact @Resource. @Resource has also property \nuri\n but it will override namespace property,\nfor example if @Resource(namespace = 'api', uri='contacts', formats = [\"json\"]) url for resource will be \nlocalhost:8080/contacts\n, not\n\n\n.Contact.groovy\n\n@Resource\n(\nnamespace\n \n=\n \napi\n,\n \nformats\n \n=\n \n[\njson\n])\n\n\nclass\n \nContact\n\n\n\n\nAlso we need to update UrlMappings.groovy, there are two ways:\n\n\n\n\nAdd \n/api\n prefix to each mapping for example  \nget \n/api/$controller(.$format)?\n(action:\nindex\n)\n\n\nUse \ngroup\n property\n\n\n\n\nWe will use the second case:\n\n\n.UrlMappings.groovy\n\npackage\n \nresttutorial\n\n\n\nclass\n \nUrlMappings\n \n{\n\n\n    \nstatic\n \nmappings\n \n=\n \n{\n\n      \ngroup\n(\n/api\n)\n \n{\n\n        \ndelete\n \n/$controller/$id(.$format)?\n(\naction:\ndelete\n)\n\n        \nget\n \n/$controller(.$format)?\n(\naction:\nindex\n)\n\n        \nget\n \n/$controller/$id(.$format)?\n(\naction:\nshow\n)\n\n        \npost\n \n/$controller(.$format)?\n(\naction:\nsave\n)\n\n        \nput\n \n/$controller/$id(.$format)?\n(\naction:\nupdate\n)\n\n        \npatch\n \n/$controller/$id(.$format)?\n(\naction:\npatch\n)\n\n      \n}\n\n        \n...\n\n    \n}\n\n\n}\n\n\n\n\nYou can see all available endpoints that Grails create for us with url-mappings-report:\n\n\n\n\n$ grails url-mappings-report\n[options=\"header\", cols=\"1,2\", grid=rows]\nDynamic Mappings\n |    *     | ERROR: 500                                | View:   /error           |\n |    *     | ERROR: 404                                | View:   /notFound        |\n |   GET    | /api/\n\\({controller}(.\\)\n{format)?            | Action: index            |\n |   POST   | /api/\n\\({controller}(.\\)\n{format)?            | Action: save             |\n |  DELETE  | /api/\n\\({controller}/\\)\n(.\n\\({format)?      | Action: delete           |\n |   GET    | /api/\\)\n/\n\\({id}(.\\)\n{format)?      | Action: show             |\n |   PUT    | /api/\n\\({controller}/\\)\n(.\n\\({format)?      | Action: update           |\n |  PATCH   | /api/\\)\n/\n\\({id}(.\\)\n{format)?      | Action: patch            |\n\n\nController: application\n |    *     | /                                                  | Action: index            |\n\n\nController: contact\n |   GET    | /api/contact/create                                | Action: create           |\n |   GET    | /api/contact/\n\\({id}/edit                            | Action: edit             |\n |   POST   | /api/contact                                       | Action: save             |\n |   GET    | /api/contact                                       | Action: index            |\n |  DELETE  | /api/contact/\\)\n                                 | Action: delete           |\n |  PATCH   | /api/contact/\n\\({id}                                 | Action: patch            |\n |   PUT    | /api/contact/\\)\n                                 | Action: update           |\n |   GET    | /api/contact/${id}                                 | Action: show             |\n\n\n\n\n=== Using CURL to test CRUD and List\n\n\nFire up the app with \nrun-app\n\n\n===== GET (list):\n\n\ncurl -i -X GET -H \"Content-Type: application/json\"  localhost:8080/api/contact\nHTTP/1.1 200\nX-Application-Context: application:development\nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:30:31 GMT\n\n\n[{\"id\":1,\"email\":\"\n\",\"firstName\":\"Marie\",\"lastName\":\"Scott\"},{\"id\":2,\"email\":\"\n\",\"firstName\":\"Joseph\",\"lastName\":\"Rodriguez\"}, ...\n\n\n===== POST:\n\n\ncurl -i -X POST -H \"Content-Type: application/json\" -d '{\"firstName\":\"Joe\", \"lastName\": \"Cool\"}' localhost:8080/api/contact\nHTTP/1.1 201\nX-Application-Context: application:development\nLocation: \nhttp://localhost:8080/api/contact/101\n\nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:30:44 GMT\n\n\n{\"id\":101,\"firstName\":\"Joe\",\"lastName\":\"Cool\"}\n\n\n===== GET (by id):\n\n\ncurl -i -X GET -H \"Content-Type: application/json\"  localhost:8080/api/contact/101\nHTTP/1.1 200\nX-Application-Context: application:development\nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:31:00 GMT\n\n\n{\"id\":101,\"firstName\":\"Joe\",\"lastName\":\"Cool\"}\n\n\n===== PUT:\n\n\ncurl -i -X PUT -H \"Content-Type: application/json\" -d '{\"firstName\": \"New Name\", \"lastName\": \"New Last name\"}' localhost:8080/api/contact/101\nHTTP/1.1 200\nX-Application-Context: application:development\nLocation: \nhttp://localhost:8080/api/contact/101\n\nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:32:01 GMT\n\n\n{\"id\":101,\"firstName\":\"New Name\",\"lastName\":\"New Last name\"}\n\n\n===== DELETE:\n\n\ncurl -i -X DELETE -H \"Content-Type: application/json\"  localhost:8080/api/contact/50\nHTTP/1.1 204\nX-Application-Context: application:development\nDate: Mon, 31 Jul 2017 12:32:24 GMT\n\n\n\n\n===== 422 - Post Validation Error:\n\n\ncurl -i -X POST -H \"Content-Type: application/json\" -d '{\"lastName\": \"Cool\"}' localhost:8080/api/contact\nHTTP/1.1 422\nX-Application-Context: application:development\nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:32:41 GMT\n\n\n{\"message\":\"Property [firstName] of class [class resttutorial.Contact] cannot be null\",\"path\":\"/contact/index\",\"_links\":{\"self\":{\"href\":\"\nhttp://localhost:8080/contact/index\n\"}}}\n\n\n===== 404 - Get Error:\n\n\ncurl -i -X GET -H \"Content-Type: application/json\"  localhost:8080/api/contact/105\nHTTP/1.1 404\nX-Application-Context: application:development\nContent-Type: application/json;charset=UTF-8\nContent-Language: en-US\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:32:55 GMT\n\n\n{\"message\":\"Not Found\",\"error\":404}\n\n\n===== 406 - NOT_ACCEPTABLE:\n\n\nWe did not setup XML support so we will get a 406. You may try adding XML to formats to see if this.\n\n\ncurl -i -X GET -H \"Accept: application/xml\"  \nhttp://localhost:8080/api/contact/8\n\nHTTP/1.1 406\nX-Application-Context: application:development\nContent-Length: 0\nDate: Mon, 31 Jul 2017 12:33:13 GMT\n\n\n\n\n=== Functional Tests for the API\n\n\nThe next step is to add functional tests for our app. One option is to use Grails functional tests and RestBuilder.\nWe will cover another javscript option later the angle-grinder section\nThe line in the buidl.gradle that allows us to use RestBuilder is\n\n\n\n\ntestCompile \"org.grails:grails-datastore-rest-client\"\n\n\nit is added by default when you create a grails app with \n-profile rest-api\n\n\n==== POST testing example\n\n\nHere is an example of \nPOST\n request (creating of a new contact).\nRestBuilder we use to emulate request from external source. Note, in Grails3 integration tests run on the random port,\nso you cant call \nhttp://localhost:8080/api/contact\n , but we can use \nserverPort\n variable instead. And to make it more\nintelligent lets use baseUrl. See example:\n\n\n.ContactSpec.groovy\n\npackage\n \nresttutorial\n\n\n\nimport\n \ngrails.plugins.rest.client.RestBuilder\n\n\nimport\n \ngrails.plugins.rest.client.RestResponse\n\n\nimport\n \ngrails.test.mixin.integration.Integration\n\n\nimport\n \norg.grails.web.json.JSONElement\n\n\nimport\n \nspock.lang.Shared\n\n\nimport\n \nspock.lang.Specification\n\n\n\n@Integration\n\n\nclass\n \nContactSpec\n \nextends\n \nSpecification\n \n{\n\n\n    \n@Shared\n\n    \nRestBuilder\n \nrest\n \n=\n \nnew\n \nRestBuilder\n()\n\n\n    \ndef\n \ngetBaseUrl\n(){\nhttp://localhost:${serverPort}/api\n}\n\n\n    \nvoid\n \ncheck POST request\n()\n \n{\n\n        \nwhen:\n\n        \nRestResponse\n \nresponse\n \n=\n \nrest\n.\npost\n(\n${baseUrl}/contact\n){\n\n          \njson\n([\n\n            \nfirstName:\n \nTest contact\n,\n\n            \nemail:\nfoo@bar.com\n,\n\n            \ninactive:\ntrue\n \n//is bindable: false - see domain, so it wont be set to contact\n\n          \n])\n\n        \n}\n\n\n        \nthen:\n\n        \nresponse\n.\nstatus\n \n==\n \n201\n\n        \nJSONElement\n \njson\n \n=\n \nresponse\n.\njson\n\n        \njson\n.\nid\n \n==\n \n101\n\n        \njson\n.\nfirstName\n \n==\n \nTest contact\n\n        \njson\n.\nlastName\n \n==\n \nnull\n\n        \njson\n.\nemail\n \n==\n \nfoo@bar.com\n\n        \njson\n.\ninactive\n \n==\n \nnull\n\n    \n}\n\n\n}\n\n\n\n\nMore tests examples are in the snapshot1 project's\n{url-snapshot1}/src/integration-test/groovy/resttutorial/ContactSpec.groovy[ContactSpec.groovy]\n\n\n=== GSON and Grails Views Defaults\n\n\nAs you can see by inspecting the views directory, by default Grails creates a number of gson files. Support for them is\nprovided with \nhttp://views.grails.org/latest/#_introduction[Grails\n Views Plugin]\n\n\nThe obvious question how does it work. If you look at sources of the RestfullController it doesn't \"call\" this templates\nexplicitly. So under the hood plugin just looks on request, if url ends on \n.json\n(localhost:8080/api/contact/1.json) or if\n\nAccept\n header containing \napplication/json\n the .gson view will be rendered.\n\n\nIf you delete default generated templates, then it will show default Grails page. Go ahead and try to delete \nnotFound.gson\n\nand try\n\n\n\n\ncurl -i -X GET -H \"Content-Type: application/json\"  localhost:8080/api/contact/105\nHTTP/1.1 404\nX-Application-Context: application:development\nContent-Type: text/html;charset=utf-8\nContent-Language: en-US\nContent-Length: 990\nDate: Mon, 31 Jul 2017 12:34:06 GMT\n\n\nApache Tomcat/8.5.5 - Error report", 
            "title": "Grails OOB(out of the box)"
        }, 
        {
            "location": "/tutorial/stock/#getting-started", 
            "text": "For this tutorial you will need    JDK (I advise 8, but you can take 7 as well).    Git.    Grails 3.2.11 (you can install it with  http://sdkman.io  on most Unix based systems.)    After all is installed clone the repo:  git clone https://github.com/9ci/angle-grinder  and switch to branch  rest_tutorial  branch, and go to  angle-grinder/grails/restTutorial , the final result is in\nthe  snapshot  folder for each step  So first let's create new grails app:  $ grails create-app -profile rest-api -features hibernate4 resttutorail\nApplication created at angle-grinder/grails/restTutorial  Grails 3 provides several different profiles you can read about them in the  grails docs", 
            "title": "Getting started"
        }, 
        {
            "location": "/tutorial/stock/#creating-an-api-with-grails-web-services", 
            "text": "As described in the  grails ws docs \nwe will use the default out of the box functionality as a starting point.", 
            "title": "Creating an API with Grails Web Services"
        }, 
        {
            "location": "/tutorial/stock/#creating-a-gorm-domain", 
            "text": "grails create-domain-class Contact  Then set it up like so:  Contact.groovy  package   resttutorial  class   Contact   { \n   String   firstName \n   String   lastName \n   String   email \n   Boolean   inactive \n\n   static   constraints   =   { \n     firstName   nullable:   false \n     inactive   bindable:   false \n   }  }   To avoid writing  nullable: true  we will set the default to allow nulls for fields\nAdd the following to  grails-app/conf/application.groovy  application.groovy  grails . gorm . default . constraints   =   { \n   *   ( nullable:   true ,   blank:   true )  }   We will load 100 rows of mock test data from a file  Contacts.json  in resources.\nThe mock data was generated from a great tool  https://www.mockaroo.com  Add the following code to  grails-app/init/BootStrap.groovy  BootStrap.groovy  package   resttutorial  import   groovy.json.JsonSlurper  class   BootStrap   { \n     def   grailsApplication \n     def   init   =   {   servletContext   - \n         def   data   =   new   JsonSlurper (). parse ( new   File ( ../resources/Contacts.json )) \n         data . each { \n           Contact   contact   =   new   Contact ( it ) \n           contact . save ( failOnError: true , flush:   true ) \n         } \n     } \n     def   destroy   =   { \n     }  }", 
            "title": "Creating a GORM domain"
        }, 
        {
            "location": "/tutorial/stock/#adding-the-resource-annotation-to-our-domain", 
            "text": ":url-dr: {docs-grails}#domainResources  So now we can start working on creating REST Api for our app.\nThe easiest way is to use {url-dr}[domain resources].\nSo as we see from {url-dr}[docs] we just need to update our domain a bit (just add {docs-grails-api}/grails/rest/Resource.html[@Resource] anotation) in such a way:  Contact.groovy  import   grails.rest.Resource  @Resource ( uri   =   /contact ,   formats   =   [ json ])  class   Contact   { \n   ...  }    :memo  On plural resource names \nAs you will notice we did not pluralize it to contacts above as many will do.\nWe are aware of the debate on this in the rest world. We feel this will cause confusion down the line to do it.   English plural rules like \"cherry/cherries\" or \"goose/geese/moose/meese\" are not the nicest thing to think of while developing API, particularly when english is not your mother tongue.  Many times, as in Grails, we want to generate endpoint from the model, which is usually singular. It does not play nicely with the above pluralization exceptions and creates more work maintaining UrlMappings.  When the model is singular, which is normally is for us, keeping the rest endpoint singular will have the rest developers and the grails developers speaking the same language  The argument \"usually you start querying by a Get to display a list\" does not refer to any real use case. And we will end up querying single items as much as and even more than a list of items.", 
            "title": "Adding the @Resource annotation to our domain"
        }, 
        {
            "location": "/tutorial/stock/#the-restfullcontroller", 
            "text": "@Resource  creates a RestfullController for the domain     The  @Resource  annotation \nis used in an ASTTransformation that creates a controller that extends RestfullController. See  ResourceTransform  for details on how it does this. Later we will show how to specify the controller to user with superClass property.", 
            "title": "The RestfullController"
        }, 
        {
            "location": "/tutorial/stock/#default-endpoints-and-status-codes", 
            "text": "", 
            "title": "Default Endpoints and Status Codes"
        }, 
        {
            "location": "/tutorial/stock/#url-mappings", 
            "text": "The  Extending Restful Controllers  section of the  grails docs  outlines the action names and the URIs they map to:  .URI, Controller Action and Response Defaults\n[cols=\"2,1,1,3\", format=\"csv\", options=\"header\", width=\"80\",grid=rows]\n|===\nURI, Method, Action, Response Data\n/contact , GET , index , Paged List\n/contact/create, GET , create , Contact.newInstance() unsaved\n/contact, POST , save , The successfully saved contact (same as show's get)\n/contact/ \\({id}, GET , show , The contact for the id\n/contact/\\) /edit, GET , edit , The contact for the id. same as show\n/contact/ \\({id}, PUT , update , The successfully updated contact\n/contact/\\) , DELETE , delete , Empty response with HTTP status code 204\n|===  ==== Status Code Defaults  Piecing together the {docs-HttpStatus}[HttpStatus codes] and results from RestfullController, RestResponder and _errors.gson,\nthese are what looks like the out of the box status codes as of Grails 3.2.2  .Status Codes Out Of Box\n[options=\"header\", cols=\"1,2\", grid=rows]\n|===\n| Status Code               | Description\n| 200 - OK                  | Everything worked as expected. default\n| 201 - CREATED             | Resource/instance was created. returned from  save  action\n| 204 - NO_CONTENT          | response code on successful DELETE request\n| 404 - NOT_FOUND           | The requested resource doesn't exist.\n| 405 - METHOD_NOT_ALLOWED  | If method (GET,POST,etc..) is not setup in  static allowedMethods  for action or resource is read only\n| 406 - NOT_ACCEPTABLE      | Accept header requests a response in an unsupported format. not configed in mime-types. RestResponder uses this\n| 422 - UNPROCESSABLE_ENTITY | Validation errors.\n|===  === API Namespace  A Namespace is a mechanism to partition resources into a logically named group.  So the controllers that response for the REST endpoints we will move to separate namespace to avoid cases when we need to\nhave Controllers for GSP rendering or some other not related to REST stuff.  As a our preferred namespace design we will use the \"api\" namespace prefix for the rest of the tutorial.\nSo we will add  namespace = 'api'  on the contact @Resource. @Resource has also property  uri  but it will override namespace property,\nfor example if @Resource(namespace = 'api', uri='contacts', formats = [\"json\"]) url for resource will be  localhost:8080/contacts , not  .Contact.groovy @Resource ( namespace   =   api ,   formats   =   [ json ])  class   Contact   Also we need to update UrlMappings.groovy, there are two ways:   Add  /api  prefix to each mapping for example   get  /api/$controller(.$format)? (action: index )  Use  group  property   We will use the second case:  .UrlMappings.groovy package   resttutorial  class   UrlMappings   { \n\n     static   mappings   =   { \n       group ( /api )   { \n         delete   /$controller/$id(.$format)? ( action: delete ) \n         get   /$controller(.$format)? ( action: index ) \n         get   /$controller/$id(.$format)? ( action: show ) \n         post   /$controller(.$format)? ( action: save ) \n         put   /$controller/$id(.$format)? ( action: update ) \n         patch   /$controller/$id(.$format)? ( action: patch ) \n       } \n         ... \n     }  }   You can see all available endpoints that Grails create for us with url-mappings-report:   $ grails url-mappings-report\n[options=\"header\", cols=\"1,2\", grid=rows]\nDynamic Mappings\n |    *     | ERROR: 500                                | View:   /error           |\n |    *     | ERROR: 404                                | View:   /notFound        |\n |   GET    | /api/ \\({controller}(.\\) {format)?            | Action: index            |\n |   POST   | /api/ \\({controller}(.\\) {format)?            | Action: save             |\n |  DELETE  | /api/ \\({controller}/\\) (. \\({format)?      | Action: delete           |\n |   GET    | /api/\\) / \\({id}(.\\) {format)?      | Action: show             |\n |   PUT    | /api/ \\({controller}/\\) (. \\({format)?      | Action: update           |\n |  PATCH   | /api/\\) / \\({id}(.\\) {format)?      | Action: patch            |  Controller: application\n |    *     | /                                                  | Action: index            |  Controller: contact\n |   GET    | /api/contact/create                                | Action: create           |\n |   GET    | /api/contact/ \\({id}/edit                            | Action: edit             |\n |   POST   | /api/contact                                       | Action: save             |\n |   GET    | /api/contact                                       | Action: index            |\n |  DELETE  | /api/contact/\\)                                  | Action: delete           |\n |  PATCH   | /api/contact/ \\({id}                                 | Action: patch            |\n |   PUT    | /api/contact/\\)                                  | Action: update           |\n |   GET    | /api/contact/${id}                                 | Action: show             |   === Using CURL to test CRUD and List  Fire up the app with  run-app", 
            "title": "Url Mappings"
        }, 
        {
            "location": "/tutorial/stock/#get-list", 
            "text": "curl -i -X GET -H \"Content-Type: application/json\"  localhost:8080/api/contact\nHTTP/1.1 200\nX-Application-Context: application:development\nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:30:31 GMT", 
            "title": "===== GET (list):"
        }, 
        {
            "location": "/tutorial/stock/#id1emailamp109amp115amp99amp111amp116amp116amp48amp64amp97amp109amp101amp98amp108amp111amp46amp106amp112firstnamemarielastnamescottid2emailamp106amp114amp111amp100amp114amp105amp103amp117amp101amp122amp49amp64amp115amp99amp114amp105amp98amp100amp46amp99amp111amp109firstnamejosephlastnamerodriguez", 
            "text": "", 
            "title": "[{\"id\":1,\"email\":\"&#109;&#115;&#99;&#111;&#116;&#116;&#48;&#64;&#97;&#109;&#101;&#98;&#108;&#111;&#46;&#106;&#112;\",\"firstName\":\"Marie\",\"lastName\":\"Scott\"},{\"id\":2,\"email\":\"&#106;&#114;&#111;&#100;&#114;&#105;&#103;&#117;&#101;&#122;&#49;&#64;&#115;&#99;&#114;&#105;&#98;&#100;&#46;&#99;&#111;&#109;\",\"firstName\":\"Joseph\",\"lastName\":\"Rodriguez\"}, ..."
        }, 
        {
            "location": "/tutorial/stock/#post", 
            "text": "curl -i -X POST -H \"Content-Type: application/json\" -d '{\"firstName\":\"Joe\", \"lastName\": \"Cool\"}' localhost:8080/api/contact\nHTTP/1.1 201\nX-Application-Context: application:development\nLocation:  http://localhost:8080/api/contact/101 \nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:30:44 GMT", 
            "title": "===== POST:"
        }, 
        {
            "location": "/tutorial/stock/#id101firstnamejoelastnamecool", 
            "text": "", 
            "title": "{\"id\":101,\"firstName\":\"Joe\",\"lastName\":\"Cool\"}"
        }, 
        {
            "location": "/tutorial/stock/#get-by-id", 
            "text": "curl -i -X GET -H \"Content-Type: application/json\"  localhost:8080/api/contact/101\nHTTP/1.1 200\nX-Application-Context: application:development\nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:31:00 GMT", 
            "title": "===== GET (by id):"
        }, 
        {
            "location": "/tutorial/stock/#id101firstnamejoelastnamecool_1", 
            "text": "", 
            "title": "{\"id\":101,\"firstName\":\"Joe\",\"lastName\":\"Cool\"}"
        }, 
        {
            "location": "/tutorial/stock/#put", 
            "text": "curl -i -X PUT -H \"Content-Type: application/json\" -d '{\"firstName\": \"New Name\", \"lastName\": \"New Last name\"}' localhost:8080/api/contact/101\nHTTP/1.1 200\nX-Application-Context: application:development\nLocation:  http://localhost:8080/api/contact/101 \nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:32:01 GMT", 
            "title": "===== PUT:"
        }, 
        {
            "location": "/tutorial/stock/#id101firstnamenew-namelastnamenew-last-name", 
            "text": "", 
            "title": "{\"id\":101,\"firstName\":\"New Name\",\"lastName\":\"New Last name\"}"
        }, 
        {
            "location": "/tutorial/stock/#delete", 
            "text": "curl -i -X DELETE -H \"Content-Type: application/json\"  localhost:8080/api/contact/50\nHTTP/1.1 204\nX-Application-Context: application:development\nDate: Mon, 31 Jul 2017 12:32:24 GMT", 
            "title": "===== DELETE:"
        }, 
        {
            "location": "/tutorial/stock/#422-post-validation-error", 
            "text": "curl -i -X POST -H \"Content-Type: application/json\" -d '{\"lastName\": \"Cool\"}' localhost:8080/api/contact\nHTTP/1.1 422\nX-Application-Context: application:development\nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:32:41 GMT", 
            "title": "===== 422 - Post Validation Error:"
        }, 
        {
            "location": "/tutorial/stock/#messageproperty-firstname-of-class-class-resttutorialcontact-cannot-be-nullpathcontactindex_linksselfhrefhttplocalhost8080contactindex", 
            "text": "", 
            "title": "{\"message\":\"Property [firstName] of class [class resttutorial.Contact] cannot be null\",\"path\":\"/contact/index\",\"_links\":{\"self\":{\"href\":\"http://localhost:8080/contact/index\"}}}"
        }, 
        {
            "location": "/tutorial/stock/#404-get-error", 
            "text": "curl -i -X GET -H \"Content-Type: application/json\"  localhost:8080/api/contact/105\nHTTP/1.1 404\nX-Application-Context: application:development\nContent-Type: application/json;charset=UTF-8\nContent-Language: en-US\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:32:55 GMT", 
            "title": "===== 404 - Get Error:"
        }, 
        {
            "location": "/tutorial/stock/#messagenot-founderror404", 
            "text": "===== 406 - NOT_ACCEPTABLE:", 
            "title": "{\"message\":\"Not Found\",\"error\":404}"
        }, 
        {
            "location": "/tutorial/stock/#we-did-not-setup-xml-support-so-we-will-get-a-406-you-may-try-adding-xml-to-formats-to-see-if-this", 
            "text": "curl -i -X GET -H \"Accept: application/xml\"   http://localhost:8080/api/contact/8 \nHTTP/1.1 406\nX-Application-Context: application:development\nContent-Length: 0\nDate: Mon, 31 Jul 2017 12:33:13 GMT   === Functional Tests for the API  The next step is to add functional tests for our app. One option is to use Grails functional tests and RestBuilder.\nWe will cover another javscript option later the angle-grinder section\nThe line in the buidl.gradle that allows us to use RestBuilder is", 
            "title": "We did not setup XML support so we will get a 406. You may try adding XML to formats to see if this."
        }, 
        {
            "location": "/tutorial/stock/#testcompile-orggrailsgrails-datastore-rest-client", 
            "text": "it is added by default when you create a grails app with  -profile rest-api  ==== POST testing example  Here is an example of  POST  request (creating of a new contact).\nRestBuilder we use to emulate request from external source. Note, in Grails3 integration tests run on the random port,\nso you cant call  http://localhost:8080/api/contact  , but we can use  serverPort  variable instead. And to make it more\nintelligent lets use baseUrl. See example:  .ContactSpec.groovy package   resttutorial  import   grails.plugins.rest.client.RestBuilder  import   grails.plugins.rest.client.RestResponse  import   grails.test.mixin.integration.Integration  import   org.grails.web.json.JSONElement  import   spock.lang.Shared  import   spock.lang.Specification  @Integration  class   ContactSpec   extends   Specification   { \n\n     @Shared \n     RestBuilder   rest   =   new   RestBuilder () \n\n     def   getBaseUrl (){ http://localhost:${serverPort}/api } \n\n     void   check POST request ()   { \n         when: \n         RestResponse   response   =   rest . post ( ${baseUrl}/contact ){ \n           json ([ \n             firstName:   Test contact , \n             email: foo@bar.com , \n             inactive: true   //is bindable: false - see domain, so it wont be set to contact \n           ]) \n         } \n\n         then: \n         response . status   ==   201 \n         JSONElement   json   =   response . json \n         json . id   ==   101 \n         json . firstName   ==   Test contact \n         json . lastName   ==   null \n         json . email   ==   foo@bar.com \n         json . inactive   ==   null \n     }  }   More tests examples are in the snapshot1 project's\n{url-snapshot1}/src/integration-test/groovy/resttutorial/ContactSpec.groovy[ContactSpec.groovy]  === GSON and Grails Views Defaults  As you can see by inspecting the views directory, by default Grails creates a number of gson files. Support for them is\nprovided with  http://views.grails.org/latest/#_introduction[Grails  Views Plugin]  The obvious question how does it work. If you look at sources of the RestfullController it doesn't \"call\" this templates\nexplicitly. So under the hood plugin just looks on request, if url ends on  .json (localhost:8080/api/contact/1.json) or if Accept  header containing  application/json  the .gson view will be rendered.  If you delete default generated templates, then it will show default Grails page. Go ahead and try to delete  notFound.gson \nand try   curl -i -X GET -H \"Content-Type: application/json\"  localhost:8080/api/contact/105\nHTTP/1.1 404\nX-Application-Context: application:development\nContent-Type: text/html;charset=utf-8\nContent-Language: en-US\nContent-Length: 990\nDate: Mon, 31 Jul 2017 12:34:06 GMT  Apache Tomcat/8.5.5 - Error report", 
            "title": "testCompile \"org.grails:grails-datastore-rest-client\""
        }, 
        {
            "location": "/glossary/", 
            "text": "", 
            "title": "Glossary"
        }
    ]
}