{
    "docs": [
        {
            "location": "/", 
            "text": "Out of the box Restful API for grails.\n\n\nThis is a library and [Grails] plugin to enhance [Gorm] to provide and expose a somewhat \nopinionated\n, \nwell documented restful API\n with intelligent out of the box defaults and minimal tweaking. It also keeps it easy to configure and customize on the fly at a deployed client site without the need to recompile.\n\n\nWhile its somewhat opinionated it frames out Rest best practices outlined in the [Rest Design Principles] section.  It uses the \nOpenAPI\n spec (formerly \nSwagger\n) as well as how it maps the Gorm domains into that spec. Its accepts and returns only JSON and eschews the complexity of XML\n\n\nWhile REST is not CRUD a lot of it really is. This project aims to makes it easy and quick to setup the common use cases that are really just CRUD Controller over the [GORM] domains so you can focus on the unique business logic use cases that are hard.\n\n\nKey features and goals of this plugin include:\n\n\n\n\nThe simple stuff should be simple and automatic\n\n\nDRY : Don't repeat yourself.\n\n\nAutogenerated code is evil. This includes tests\n\n\nUse AST, traits and tanspiling where possible \n\n\n\n\n\n\n\n\n Near zero configuration to expose \nSwagger\n documented resources (the Gorm domains)\n\n\n Rely on the domain's contraints as much as possible for configurations and docs.\n\n\n Out of the box CRUD Controller modified from Grails \n@Resource annotation and RestfulController\n that can delegate to transactional Services (DAOs Repositories, Data Services) flavored services based on naming convention or configuration. Uses the [DAO] plugin by deafault for this.\n\n\n Custom schema selects for retruned JSON fields that can be confiugured at runtime by a customer (does not require recompiling views)\n\n\n Consistent documented use of HTTP status codes and headers\n\n\n Uses \ncache-headers\n for faster loading\n\n\n Use [Services/DAO/Repository] pattern by defualt to keep the CRUD code in its own transactional service\n\n\n Ability to 'query by POST' (to allow query criteria to be provided within the request body)\n\n\n Intelligent defaults for security plugin with OATH and JWT.\n\n\n Tools to ease GEB functional tests with Spock\n\n\n Extensive regression tests\n\n\n\n\nInstall", 
            "title": "Overview"
        }, 
        {
            "location": "/#out-of-the-box-restful-api-for-grails", 
            "text": "This is a library and [Grails] plugin to enhance [Gorm] to provide and expose a somewhat  opinionated ,  well documented restful API  with intelligent out of the box defaults and minimal tweaking. It also keeps it easy to configure and customize on the fly at a deployed client site without the need to recompile.  While its somewhat opinionated it frames out Rest best practices outlined in the [Rest Design Principles] section.  It uses the  OpenAPI  spec (formerly  Swagger ) as well as how it maps the Gorm domains into that spec. Its accepts and returns only JSON and eschews the complexity of XML  While REST is not CRUD a lot of it really is. This project aims to makes it easy and quick to setup the common use cases that are really just CRUD Controller over the [GORM] domains so you can focus on the unique business logic use cases that are hard.  Key features and goals of this plugin include:   The simple stuff should be simple and automatic  DRY : Don't repeat yourself.  Autogenerated code is evil. This includes tests  Use AST, traits and tanspiling where possible       Near zero configuration to expose  Swagger  documented resources (the Gorm domains)   Rely on the domain's contraints as much as possible for configurations and docs.   Out of the box CRUD Controller modified from Grails  @Resource annotation and RestfulController  that can delegate to transactional Services (DAOs Repositories, Data Services) flavored services based on naming convention or configuration. Uses the [DAO] plugin by deafault for this.   Custom schema selects for retruned JSON fields that can be confiugured at runtime by a customer (does not require recompiling views)   Consistent documented use of HTTP status codes and headers   Uses  cache-headers  for faster loading   Use [Services/DAO/Repository] pattern by defualt to keep the CRUD code in its own transactional service   Ability to 'query by POST' (to allow query criteria to be provided within the request body)   Intelligent defaults for security plugin with OATH and JWT.   Tools to ease GEB functional tests with Spock   Extensive regression tests", 
            "title": "Out of the box Restful API for grails."
        }, 
        {
            "location": "/#install", 
            "text": "", 
            "title": "Install"
        }, 
        {
            "location": "/quick-start/", 
            "text": "A Grails Rest API in 60 seconds\n\n\nCreat a new grails app ( this was done with 3.2.11 )\n\ngrails create-app restify --profile=rest-api\n\n\n\nTo use gorm-rest-api in Grails 3 you can specify the following configuration in build.gradle:\n\n\n    dependencies {\n        compile \norg.grails.plugins:gorm-rest-api\n\n    }\n\n\n\n\n\ncreate a domain\n\n\ngrails create-rest-domain restify.AppUser\n\n\n\n\nThis will create a domain in grails-app/domain/restify/ as well as an integration test.\n\nEdit AppUser and we'll add a few fields with descriptions and examples so our Swagger/OpenApi docs look good. This will also feed our [functional] tests\n\n\npackage\n \nbits\n\n\nimport\n \ngorm.restapi.RestApi\n\n\n\n@RestApi\n(\ndescription\n \n=\n \nThe user for the restify application\n)\n\n\nclass\n \nAppUser\n \n{\n\n    \nString\n \nuserName\n\n    \nSting\n \nmagicCode\n\n    \nSting\n \nemail\n\n\n    \nDate\n \ndateCreated\n\n    \nDate\n \nlastUpdated\n\n\n    \nstatic\n \nconstraints\n \n=\n \n{\n\n        \nuserName\n  \ndescription:\n \nThe login name\n,\n \n                  \nexample:\nbilly1\n,\n\n                  \nnullable:\n \nfalse\n,\n \nmaxSize:\n50\n\n        \nmagicCode\n \ndescription:\n \nThe keymaster code. Some call this a password\n\n                  \nexample:\nb4d_p455w0rd\n,\n \n                  \nnullable:\n \nfalse\n\n        \nemail\n     \ndescription:\n \nEmail will be used for evil.\n,\n\n                  \nexample:\nbilly@gmail.com\n,\n\n                  \nemail:\ntrue\n,\n \nmaxSize:\n50\n,\n \nnullable:\n \ntrue\n\n    \n}\n\n\n\n}\n\n\n\n\n\nnow run \ngrails test-app\n to see the api exercised. \n\n\nLets try \nrun-app\n with curl\n\n\ninsert a user\n\n\ncurl -i -X POST -H \nContent-Type: application/json\n -d \n{\nuserName\n:\nJoe\n, \nmagicCode\n: \nCool\n}\n localhost:8080/api/appUser\nHTTP/1.1 \n201\n\nX-Application-Context: application:development\nLocation: http://localhost:8080/api/appUser/1\nContent-Type: application/json\n;\ncharset\n=\nUTF-8\nTransfer-Encoding: chunked\nDate: Fri, \n11\n Aug \n2017\n \n07\n:34:05 GMT\n\n\n{\nid\n:1,\ndateCreated\n:\n2017-08-11T07:34:05Z\n,\nlastUpdated\n:\n2017-08-11T07:34:05Z\n,\nmagicCode\n:\nCool\n,\nuserName\n:\nJoe\n}\n\n\n\n\nlist users\n\n\ncurl -i -X GET -H \nContent-Type: application/json\n localhost:8080/api/appUser\nHTTP/1.1 \n200\n\n--8\n-- snipped ...\n\n\n[{\nid\n:1,\ndateCreated\n:\n2017-08-11T07:34:05Z\n,\nlastUpdated\n:\n2017-08-11T07:34:05Z\n,\nmagicCode\n:\nCool\n,\nuserName\n:\nJoe\n}]\n\n\n\n\nJSON Schema\n\n\ncurl\n \n-\ni\n \nlocalhost\n:\n8080\n/\napi\n/\nappUser\n/\nschema\n\n\n\n{\n\n    \n$schema\n:\n \nhttp://json-schema.org/schema#\n,\n\n    \n$id\n:\n \nhttp://localhost:8080/api/schema/appUser#\n,\n\n    \ntitle\n:\n \nAppUser\n,\n\n    \nDescription\n:\nThe user for the restify application\n,\n\n    \ntype\n:\n \nObject\n,\n\n    \nrequired\n:\n \n[\n\n        \nuserName\n,\n\n        \nmagicCode\n\n    \n],\n\n    \nproperties\n:\n \n{\n\n        \nid\n:\n \n{\n\n            \ntype\n:\n \ninteger\n,\n\n            \nreadOnly\n:\n \ntrue\n\n        \n},\n\n        \nversion\n:\n \n{\n\n            \ntype\n:\n \ninteger\n,\n\n            \nreadOnly\n:\n \ntrue\n\n        \n},\n\n        \nuserName\n:\n \n{\n\n            \ntitle\n:\n \nUser Name\n,\n\n            \ndescription\n:\n \nThe login name\n,\n\n            \nexample\n:\n \nbilly1\n,\n\n            \ntype\n:\n \nstring\n,\n\n            \nrequired\n:\n \ntrue\n,\n\n            \nmaxLength\n:\n \n50\n\n        \n},\n\n        \nmagicCode\n:\n \n{\n\n            \ntitle\n:\n \nMagic Code\n,\n\n            \ndescription\n:\n \nThe keymaster code. Some call this a password\n,\n\n            \nexample\n:\n \nb4d_p455w0rd\n,\n\n            \ntype\n:\n \nstring\n,\n\n            \nrequired\n:\n \ntrue\n\n        \n},\n\n        \nemail\n:\n \n{\n\n            \ntitle\n:\n \nEmail\n,\n\n            \ndescription\n:\n \nEmail will be used for evil.\n,\n\n            \nexample\n:\n \nbilly@gmail.com\n,\n\n            \ntype\n:\n \nstring\n,\n\n            \nformat\n:\n \nemail\n,\n\n            \nmaxLength\n:\n \n50\n\n        \n},\n\n        \nlastUpdated\n:\n \n{\n\n            \ntitle\n:\n \nLast Updated\n,\n\n            \ntype\n:\n \nstring\n,\n\n            \nformat\n:\n \ndate-time\n,\n\n            \nreadOnly\n:\n \ntrue\n\n        \n},\n\n        \ndateCreated\n:\n \n{\n\n            \ntitle\n:\n \nDate Created\n,\n\n            \ntype\n:\n \nstring\n,\n\n            \nformat\n:\n \ndate-time\n,\n\n            \nreadOnly\n:\n \ntrue\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\nOpenApi Swagger\n\n\nOpen a browser and go to \nhttp://localhost:8080/swagger.html\n\n\n\n\nto see yml that feeds this check out localhost:8080/api/open-api.yml\n\n\nswagger\n:\n \n2.0\n\n\ninfo\n:\n\n  \ndescription\n:\n \nTODO\n\n  \nversion\n:\n \n0.1\n\n  \ntitle\n:\n \nRestify\n\n\nhost\n:\n \nlocalhost:8080\n\n\nbasePath\n:\n \n/api\n\n\ntags\n:\n\n\n-\n \nname\n:\n \nappUser\n\n  \ndescription\n:\n \nThe\n \nuser\n \nfor\n \nthe\n \nrestify\n \napplication\n\n\npaths\n:\n\n  \n/appUser\n:\n\n    \npost\n:\n\n      \ntags\n:\n\n        \n-\n \nappUser\n\n      \nsummary\n:\n \nAdd\n \na\n \nnew\n \nApp\n \nUser\n\n      \ndescription\n:\n \n\n      \noperationId\n:\n \ncreate_appUser\n\n      \nparameters\n:\n\n      \n-\n \nin\n:\n \nbody\n\n        \nname\n:\n \nObject\n\n        \ndescription\n:\n \nApp\n \nUser\n \nobject\n \nto\n \nbe\n \ncreated\n\n        \nrequired\n:\n \ntrue\n\n        \nschema\n:\n\n          \n$ref\n:\n \n#/definitions/AppUser\n\n      \nresponses\n:\n\n        \n200\n:\n\n          \ndescription\n:\n \nsuccess\n\n          \nschema\n:\n\n            \n$ref\n:\n \n#/definitions/AppUser\n\n        \n422\n:\n\n          \ndescription\n:\n \nValidation\n \nexception\n\n    \nget\n:\n\n      \ntags\n:\n\n      \n-\n \nappUser\n\n      \nsummary\n:\n \nList\n \nApp\n \nUsers\n\n      \noperationId\n:\n \nfindAppUsers\n\n      \nresponses\n:\n\n        \n200\n:\n\n          \ndescription\n:\n \nsuccessful\n \noperation\n\n          \nschema\n:\n\n            \ntype\n:\n \narray\n\n            \nitems\n:\n\n              \n$ref\n:\n \n#/definitions/AppUser\n\n        \n400\n:\n\n          \ndescription\n:\n \nInvalid\n \nstatus\n \nvalue\n\n  \n/appUser/{id}\n:\n\n    \nget\n:\n\n      \ntags\n:\n\n      \n-\n \nappUser\n\n      \nsummary\n:\n \nGet\n \nApp\n \nUser\n \nby\n \nID\n\n      \noperationId\n:\n \nget_appUserById\n\n      \nproduces\n:\n\n      \n-\n \napplication/json\n\n      \nparameters\n:\n\n      \n-\n \nname\n:\n \nid\n\n        \nin\n:\n \npath\n\n        \ndescription\n:\n \nID\n \nof\n \n[AppUser]\n \nto\n \nreturn\n\n        \nrequired\n:\n \ntrue\n\n        \ntype\n:\n \ninteger\n\n        \nformat\n:\n \nint64\n\n      \nresponses\n:\n\n        \n200\n:\n\n          \ndescription\n:\n \nsuccessful\n \noperation\n\n          \nschema\n:\n\n            \n$ref\n:\n \n#/definitions/AppUser\n\n        \n400\n:\n\n          \ndescription\n:\n \nInvalid\n \nID\n \nsupplied\n\n        \n404\n:\n\n          \ndescription\n:\n \nnot\n \nfound\n\n    \npatch\n:\n\n      \ntags\n:\n\n      \n-\n \nappUser\n\n      \nsummary\n:\n \nUpdate\n \nan\n \nexisting\n \nApp\n \nUser\n\n      \ndescription\n:\n \n\n      \noperationId\n:\n \nupdate_appUser\n\n      \nconsumes\n:\n\n      \n-\n \napplication/json\n\n      \nproduces\n:\n\n      \n-\n \napplication/json\n\n      \nparameters\n:\n\n      \n-\n \nin\n:\n \nbody\n\n        \nname\n:\n \nbody\n\n        \ndescription\n:\n \nAppUser\n \nobject\n \nthat\n \nneeds\n \nto\n \nbe\n \nupdated\n\n        \nrequired\n:\n \ntrue\n\n        \nschema\n:\n\n          \n$ref\n:\n \n#/definitions/AppUser\n\n      \nresponses\n:\n\n        \n400\n:\n\n          \ndescription\n:\n \nInvalid\n \nID\n \nsupplied\n\n        \n404\n:\n\n          \ndescription\n:\n \nnot\n \nfound\n\n        \n422\n:\n\n          \ndescription\n:\n \nValidation\n \nexception\n\n    \ndelete\n:\n\n      \ntags\n:\n\n      \n-\n \nappUser\n\n      \nsummary\n:\n \nDeletes\n \na\n \n[App\n \nUser]\n\n      \ndescription\n:\n \n\n      \noperationId\n:\n \ndeleteAppUser\n\n      \nproduces\n:\n\n      \n-\n \napplication/json\n\n      \nparameters\n:\n\n      \n-\n \nname\n:\n \nid\n\n        \nin\n:\n \npath\n\n        \ndescription\n:\n \nid\n \nto\n \ndelete\n\n        \nrequired\n:\n \ntrue\n\n        \ntype\n:\n \ninteger\n\n        \nformat\n:\n \nint64\n\n      \nresponses\n:\n\n        \n400\n:\n\n          \ndescription\n:\n \nInvalid\n \nID\n \nsupplied\n\n        \n404\n:\n\n          \ndescription\n:\n \nnot\n \nfound\n\n\ndefinitions\n:\n\n  \nAppUser\n:\n\n    \ntype\n:\n \nobject\n\n    \nrequired\n:\n\n    \n-\n \nuserName\n\n    \n-\n \nmagicCode\n\n    \nproperties\n:\n\n      \nid\n:\n\n        \ntype\n:\n \ninteger\n\n        \nformat\n:\n \nint64\n\n        \nreadOnly\n:\n \ntrue\n\n      \nuserName\n:\n\n        \ntitle\n:\n \nUser Name\n\n        \ndescription\n:\n \nThe login name\n\n        \nexample\n:\n \nbilly1\n\n        \ntype\n:\n \nstring\n\n        \nmaxLength\n:\n \n50\n\n      \nmagicCode\n:\n\n        \ntitle\n:\n \nMagic Code\n\n        \ndescription\n:\n \nThe keymaster code. Some call this a password\n\n        \nexample\n:\n \nb4d_p455w0rd\n\n        \ntype\n:\n \nstring\n\n      \nemail\n:\n\n        \ntitle\n:\n \nEmail\n\n        \ndescription\n:\n \nEmail will be used for evil.\n\n        \nexample\n:\n \nbilly@gmail.com\n\n        \ntype\n:\n \nstring\n\n        \nformat\n:\n \nemail\n\n        \nmaxLength\n:\n \n50\n\n      \nlastUpdated\n:\n\n        \ntitle\n:\n \nLast Updated\n\n        \ntype\n:\n \nstring\n\n        \nformat\n:\n \ndate-time\n\n        \nreadOnly\n:\n \ntrue\n\n      \ndateCreated\n:\n\n        \ntitle\n:\n \nDate Created\n\n        \ntype\n:\n \nstring\n\n        \nformat\n:\n \ndate-time\n\n        \nreadOnly\n:\n \ntrue\n\n\n\nAdd org to AppUser so it looks like this now\n\n\npackage\n \nbits\n\n\nimport\n \ngorm.restapi.RestApi\n\n\n\n@RestApi\n(\ndescription\n \n=\n \nThe user for the bits and bytes application\n)\n\n\nclass\n \nAppUser\n \n{\n\n    \nString\n \nuserName\n\n    \nSting\n \nmagicCode\n\n    \nSting\n \nemail\n\n    \nOrg\n \norg\n\n\n    \nstatic\n \nconstraints\n \n=\n \n{\n\n        \nuserName\n  \ndescription:\n \nThe login name\n,\n \nexample:\nbilly\n,\n\n                  \nblank:\n \nfalse\n,\n \nunique:\n \ntrue\n,\n \nnullable:\n \nfalse\n\n        \nmagicCode\n \ndescription:\n \nThe keymaster code. Some call this a password\n\n                  \nexample:\nb4d_p455w0rd\n,\n \n                  \nblank:\n \nfalse\n,\n \npassword:\n \ntrue\n,\n \nnullable:\n \nfalse\n\n        \nemail\n     \ndescription:\n \nEmail will be used for evil.\n,\n\n                  \nexample:\nbilly@billyboy.com\n,\n\n                  \nemail:\ntrue\n,\n \nmaxSize:\n50\n,\n \nnullable:\n \ntrue\n\n        \norg\n       \ndescription:\n \nThe organization this user belongs to\n,\n\n                  \ntitle:\n \nOrganization\n\n                  \nexample:\n{\nid\n:1}\n,\n\n                  \nnullable:\n \nfalse\n\n    \n}\n\n\n\n}\n\n\n\n\n\nAdd fields to Org\n\n\npackage\n \nbits\n\n\nimport\n \ngorm.restapi.RestApi\n\n\n\n@RestApi\n(\ndescription\n \n=\n \nThe _organizations_ and _tribes_ we all belong to\n)\n\n\nclass\n \nOrg\n \n{\n\n    \nString\n \nnum\n\n    \nString\n \nname\n\n\n    \nstatic\n \nconstraints\n \n=\n \n{\n\n        \nnum\n   \ndescription:\n \nidentifier or nickname\n,\n \n              \nexample:\nvg1\n,\n\n              \nmaxSize:\n10\n,\n \nnullable:\n \ntrue\n\n        \nname\n  \ndescription:\n \nName of this organizatoin\n,\n \n              \nexample:\nVirgin Galactic\n,\n\n              \nmaxSize:\n50\n,\n \nnullable:\n \nfalse\n\n    \n}\n\n\n}", 
            "title": "Quick Start Guide"
        }, 
        {
            "location": "/quick-start/#a-grails-rest-api-in-60-seconds", 
            "text": "Creat a new grails app ( this was done with 3.2.11 ) grails create-app restify --profile=rest-api  To use gorm-rest-api in Grails 3 you can specify the following configuration in build.gradle:      dependencies {\n        compile  org.grails.plugins:gorm-rest-api \n    }  create a domain  grails create-rest-domain restify.AppUser  This will create a domain in grails-app/domain/restify/ as well as an integration test. \nEdit AppUser and we'll add a few fields with descriptions and examples so our Swagger/OpenApi docs look good. This will also feed our [functional] tests  package   bits  import   gorm.restapi.RestApi  @RestApi ( description   =   The user for the restify application )  class   AppUser   { \n     String   userName \n     Sting   magicCode \n     Sting   email \n\n     Date   dateCreated \n     Date   lastUpdated \n\n     static   constraints   =   { \n         userName    description:   The login name ,  \n                   example: billy1 , \n                   nullable:   false ,   maxSize: 50 \n         magicCode   description:   The keymaster code. Some call this a password \n                   example: b4d_p455w0rd ,  \n                   nullable:   false \n         email       description:   Email will be used for evil. , \n                   example: billy@gmail.com , \n                   email: true ,   maxSize: 50 ,   nullable:   true \n     }  }   now run  grails test-app  to see the api exercised.", 
            "title": "A Grails Rest API in 60 seconds"
        }, 
        {
            "location": "/quick-start/#lets-try-run-app-with-curl", 
            "text": "insert a user  curl -i -X POST -H  Content-Type: application/json  -d  { userName : Joe ,  magicCode :  Cool }  localhost:8080/api/appUser\nHTTP/1.1  201 \nX-Application-Context: application:development\nLocation: http://localhost:8080/api/appUser/1\nContent-Type: application/json ; charset = UTF-8\nTransfer-Encoding: chunked\nDate: Fri,  11  Aug  2017   07 :34:05 GMT { id :1, dateCreated : 2017-08-11T07:34:05Z , lastUpdated : 2017-08-11T07:34:05Z , magicCode : Cool , userName : Joe }   list users  curl -i -X GET -H  Content-Type: application/json  localhost:8080/api/appUser\nHTTP/1.1  200 \n--8 -- snipped ... [{ id :1, dateCreated : 2017-08-11T07:34:05Z , lastUpdated : 2017-08-11T07:34:05Z , magicCode : Cool , userName : Joe }]   JSON Schema  curl   - i   localhost : 8080 / api / appUser / schema  { \n     $schema :   http://json-schema.org/schema# , \n     $id :   http://localhost:8080/api/schema/appUser# , \n     title :   AppUser , \n     Description : The user for the restify application , \n     type :   Object , \n     required :   [ \n         userName , \n         magicCode \n     ], \n     properties :   { \n         id :   { \n             type :   integer , \n             readOnly :   true \n         }, \n         version :   { \n             type :   integer , \n             readOnly :   true \n         }, \n         userName :   { \n             title :   User Name , \n             description :   The login name , \n             example :   billy1 , \n             type :   string , \n             required :   true , \n             maxLength :   50 \n         }, \n         magicCode :   { \n             title :   Magic Code , \n             description :   The keymaster code. Some call this a password , \n             example :   b4d_p455w0rd , \n             type :   string , \n             required :   true \n         }, \n         email :   { \n             title :   Email , \n             description :   Email will be used for evil. , \n             example :   billy@gmail.com , \n             type :   string , \n             format :   email , \n             maxLength :   50 \n         }, \n         lastUpdated :   { \n             title :   Last Updated , \n             type :   string , \n             format :   date-time , \n             readOnly :   true \n         }, \n         dateCreated :   { \n             title :   Date Created , \n             type :   string , \n             format :   date-time , \n             readOnly :   true \n         } \n     }  }", 
            "title": "Lets try run-app with curl"
        }, 
        {
            "location": "/quick-start/#openapi-swagger", 
            "text": "Open a browser and go to  http://localhost:8080/swagger.html   to see yml that feeds this check out localhost:8080/api/open-api.yml  swagger :   2.0  info : \n   description :   TODO \n   version :   0.1 \n   title :   Restify  host :   localhost:8080  basePath :   /api  tags :  -   name :   appUser \n   description :   The   user   for   the   restify   application  paths : \n   /appUser : \n     post : \n       tags : \n         -   appUser \n       summary :   Add   a   new   App   User \n       description :   \n       operationId :   create_appUser \n       parameters : \n       -   in :   body \n         name :   Object \n         description :   App   User   object   to   be   created \n         required :   true \n         schema : \n           $ref :   #/definitions/AppUser \n       responses : \n         200 : \n           description :   success \n           schema : \n             $ref :   #/definitions/AppUser \n         422 : \n           description :   Validation   exception \n     get : \n       tags : \n       -   appUser \n       summary :   List   App   Users \n       operationId :   findAppUsers \n       responses : \n         200 : \n           description :   successful   operation \n           schema : \n             type :   array \n             items : \n               $ref :   #/definitions/AppUser \n         400 : \n           description :   Invalid   status   value \n   /appUser/{id} : \n     get : \n       tags : \n       -   appUser \n       summary :   Get   App   User   by   ID \n       operationId :   get_appUserById \n       produces : \n       -   application/json \n       parameters : \n       -   name :   id \n         in :   path \n         description :   ID   of   [AppUser]   to   return \n         required :   true \n         type :   integer \n         format :   int64 \n       responses : \n         200 : \n           description :   successful   operation \n           schema : \n             $ref :   #/definitions/AppUser \n         400 : \n           description :   Invalid   ID   supplied \n         404 : \n           description :   not   found \n     patch : \n       tags : \n       -   appUser \n       summary :   Update   an   existing   App   User \n       description :   \n       operationId :   update_appUser \n       consumes : \n       -   application/json \n       produces : \n       -   application/json \n       parameters : \n       -   in :   body \n         name :   body \n         description :   AppUser   object   that   needs   to   be   updated \n         required :   true \n         schema : \n           $ref :   #/definitions/AppUser \n       responses : \n         400 : \n           description :   Invalid   ID   supplied \n         404 : \n           description :   not   found \n         422 : \n           description :   Validation   exception \n     delete : \n       tags : \n       -   appUser \n       summary :   Deletes   a   [App   User] \n       description :   \n       operationId :   deleteAppUser \n       produces : \n       -   application/json \n       parameters : \n       -   name :   id \n         in :   path \n         description :   id   to   delete \n         required :   true \n         type :   integer \n         format :   int64 \n       responses : \n         400 : \n           description :   Invalid   ID   supplied \n         404 : \n           description :   not   found  definitions : \n   AppUser : \n     type :   object \n     required : \n     -   userName \n     -   magicCode \n     properties : \n       id : \n         type :   integer \n         format :   int64 \n         readOnly :   true \n       userName : \n         title :   User Name \n         description :   The login name \n         example :   billy1 \n         type :   string \n         maxLength :   50 \n       magicCode : \n         title :   Magic Code \n         description :   The keymaster code. Some call this a password \n         example :   b4d_p455w0rd \n         type :   string \n       email : \n         title :   Email \n         description :   Email will be used for evil. \n         example :   billy@gmail.com \n         type :   string \n         format :   email \n         maxLength :   50 \n       lastUpdated : \n         title :   Last Updated \n         type :   string \n         format :   date-time \n         readOnly :   true \n       dateCreated : \n         title :   Date Created \n         type :   string \n         format :   date-time \n         readOnly :   true  \nAdd org to AppUser so it looks like this now  package   bits  import   gorm.restapi.RestApi  @RestApi ( description   =   The user for the bits and bytes application )  class   AppUser   { \n     String   userName \n     Sting   magicCode \n     Sting   email \n     Org   org \n\n     static   constraints   =   { \n         userName    description:   The login name ,   example: billy , \n                   blank:   false ,   unique:   true ,   nullable:   false \n         magicCode   description:   The keymaster code. Some call this a password \n                   example: b4d_p455w0rd ,  \n                   blank:   false ,   password:   true ,   nullable:   false \n         email       description:   Email will be used for evil. , \n                   example: billy@billyboy.com , \n                   email: true ,   maxSize: 50 ,   nullable:   true \n         org         description:   The organization this user belongs to , \n                   title:   Organization \n                   example: { id :1} , \n                   nullable:   false \n     }  }   Add fields to Org  package   bits  import   gorm.restapi.RestApi  @RestApi ( description   =   The _organizations_ and _tribes_ we all belong to )  class   Org   { \n     String   num \n     String   name \n\n     static   constraints   =   { \n         num     description:   identifier or nickname ,  \n               example: vg1 , \n               maxSize: 10 ,   nullable:   true \n         name    description:   Name of this organizatoin ,  \n               example: Virgin Galactic , \n               maxSize: 50 ,   nullable:   false \n     }  }", 
            "title": "OpenApi Swagger"
        }, 
        {
            "location": "/swagger-openapi/", 
            "text": "OpenAPI Specification (OAS)\n\n\n\n\nThe \nOpenAPI\n Specification (OAS) defines a standard, language-agnostic interface to RESTful APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection.\n\n\n\n\nOAS\n formerly known as \nSwagger\n and they donated it to the Linux Foundation to become OpenAPI (Swagger is a better name) . Swagger was version 2.0 and current version of \nOAS\n is 3.0. \n\n\nOAS is a super set of \njson-schema\n. In Grails or Spring, OAS describes both the controllers and actions as well the domains. Its uses \njson-schema\n, particularly the validation spec to describe the domains. \n\n\n\n\n See \nhere for an example\n of the Swagger 2.0 spec in action.\n\n\n\n\nGoals\n\n\nThere are 2 primary goals of getting OAS and json-schema setup for our Grails Gorm domains\n\n\n\n\nEnable automatic generation of forms with something like \nSchema Form\n\n\nAutogenerate docs like some of the examples links below\n\n\n\n\njson-schema docs, specs and examples\n\n\n\n\n \n\n\n\n\njson-schema\n\n\njson-schema example\n\n\njson-schema Spec\n\n\njson-schema Validation Spec\n\n\nExamples\n \n\n\nspacetelescope has a \nDecent guide\n\n\nAnother \nexample\n of what we are after\n\n\n\n\n\n\nOther Articles \n Tutorials\n\n\nhttps://brandur.org/elegant-apis\n\n\nhttps://blog.cloudflare.com/cloudflares-json-powered-documentation-generator/\n\n\nSwagger\n\n\nSwagger is a superset of json-schema. See \nhttp://editor.swagger.io/#/\n for an example\nAnd the Swagger site for plenty of examples\n\n\nDoc Engines\n\n\nIf we have our API defined in Swagger and/or json-schema or yml then we can use something like \n\nhttps://github.com/mermade/widdershins\n to generate a slate based doc site\nSee \nhttp://mikeralphson.github.io/openapi/2016/12/19/oa2s-comparison\n \nExample site \nhttps://mermade.github.io/shins/#swagger-petstore-v1-0-0\n \n\n\nAs mentioned in widdershins if we are using a message queue then this is worth looking at for \n\n\nOther Resources\n\n\nVueJs\n\n\nhttps://github.com/koumoul-dev/vue-openapi\n\n\nhttps://github.com/koumoul-dev/openapi-viewer\n\n\nExamples\n\n\nhttp://swapi.co/\n\n\nhttps://projects.spring.io/spring-restdocs/\n\n\nJava version of schema validator\n\nhttps://github.com/java-json-tools/json-schema-validator\n\n\njavadoc to markdown\n\n\nhttps://delight-im.github.io/Javadoc-to-Markdown/\n\n\nUsing javadocs or annotations\n\n\nThese are some possibilities to generate swagger or docs from javadocs ideally\n\nhttps://wiki.onosproject.org/display/ONOS/Generating+Swagger+documentation+for+the+REST+API\n\n\nThis provides a pretty good overview of 4 options. Swagger(spring fox), Spring REST Docs, RAML, ApiDocJS\n\nhttps://opencredo.com/rest-api-tooling-review/\n and Spring Fox looks promising \nhttp://springfox.github.io/springfox/docs/current/\n there seems to be a version for Grails too, \nhttps://github.com/springfox/springfox-grails-integration", 
            "title": "OpenAPI/Schema Notes"
        }, 
        {
            "location": "/swagger-openapi/#openapi-specification-oas", 
            "text": "The  OpenAPI  Specification (OAS) defines a standard, language-agnostic interface to RESTful APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection.   OAS  formerly known as  Swagger  and they donated it to the Linux Foundation to become OpenAPI (Swagger is a better name) . Swagger was version 2.0 and current version of  OAS  is 3.0.   OAS is a super set of  json-schema . In Grails or Spring, OAS describes both the controllers and actions as well the domains. Its uses  json-schema , particularly the validation spec to describe the domains.     See  here for an example  of the Swagger 2.0 spec in action.", 
            "title": "OpenAPI Specification (OAS)"
        }, 
        {
            "location": "/swagger-openapi/#goals", 
            "text": "There are 2 primary goals of getting OAS and json-schema setup for our Grails Gorm domains   Enable automatic generation of forms with something like  Schema Form  Autogenerate docs like some of the examples links below", 
            "title": "Goals"
        }, 
        {
            "location": "/swagger-openapi/#json-schema-docs-specs-and-examples", 
            "text": "json-schema  json-schema example  json-schema Spec  json-schema Validation Spec  Examples    spacetelescope has a  Decent guide  Another  example  of what we are after", 
            "title": "json-schema docs, specs and examples"
        }, 
        {
            "location": "/swagger-openapi/#other-articles-tutorials", 
            "text": "https://brandur.org/elegant-apis  https://blog.cloudflare.com/cloudflares-json-powered-documentation-generator/", 
            "title": "Other Articles &amp; Tutorials"
        }, 
        {
            "location": "/swagger-openapi/#swagger", 
            "text": "Swagger is a superset of json-schema. See  http://editor.swagger.io/#/  for an example\nAnd the Swagger site for plenty of examples", 
            "title": "Swagger"
        }, 
        {
            "location": "/swagger-openapi/#doc-engines", 
            "text": "If we have our API defined in Swagger and/or json-schema or yml then we can use something like  https://github.com/mermade/widdershins  to generate a slate based doc site\nSee  http://mikeralphson.github.io/openapi/2016/12/19/oa2s-comparison  \nExample site  https://mermade.github.io/shins/#swagger-petstore-v1-0-0    As mentioned in widdershins if we are using a message queue then this is worth looking at for", 
            "title": "Doc Engines"
        }, 
        {
            "location": "/swagger-openapi/#other-resources", 
            "text": "", 
            "title": "Other Resources"
        }, 
        {
            "location": "/swagger-openapi/#vuejs", 
            "text": "https://github.com/koumoul-dev/vue-openapi  https://github.com/koumoul-dev/openapi-viewer", 
            "title": "VueJs"
        }, 
        {
            "location": "/swagger-openapi/#examples", 
            "text": "http://swapi.co/  https://projects.spring.io/spring-restdocs/  Java version of schema validator https://github.com/java-json-tools/json-schema-validator", 
            "title": "Examples"
        }, 
        {
            "location": "/swagger-openapi/#javadoc-to-markdown", 
            "text": "https://delight-im.github.io/Javadoc-to-Markdown/", 
            "title": "javadoc to markdown"
        }, 
        {
            "location": "/swagger-openapi/#using-javadocs-or-annotations", 
            "text": "These are some possibilities to generate swagger or docs from javadocs ideally https://wiki.onosproject.org/display/ONOS/Generating+Swagger+documentation+for+the+REST+API  This provides a pretty good overview of 4 options. Swagger(spring fox), Spring REST Docs, RAML, ApiDocJS https://opencredo.com/rest-api-tooling-review/  and Spring Fox looks promising  http://springfox.github.io/springfox/docs/current/  there seems to be a version for Grails too,  https://github.com/springfox/springfox-grails-integration", 
            "title": "Using javadocs or annotations"
        }, 
        {
            "location": "/design-principles/guidelines/", 
            "text": "see:\n\nhttps://zalando.github.io/restful-api-guidelines/tooling/Tooling.html\n\n\nAPI as a Product\n\n\nWe are transforming to a platform comprising a rich set of products following a Software as a Platform (SaaS) model for our business partners. We want to deliver products to our customers which can be consumed like a service.\n\n\nPlatform products provide their functionality via (public) APIs; hence, the design of our APIs should be based on the API as a Product principle:\n\n\n\n\nTreat your API as product and understand the needs of its customers\n\n\nTake ownership and advocate for the customer and continuous improvement\n\n\nEmphasize easy understanding, discovery and usage of APIs; design APIs irresistible for client engineers\n\n\nActively improve and maintain API consistency over the long term\n\n\nMake use of customer feedback and provide service level support\n\n\nRESTful API as a Product makes the difference between enterprise integration business and agile, innovative product service business built on a platform of APIs.\n\n\nare easy to understand and learn\n\n\nare general and abstracted from specific implementation and use cases\n\n\nhave a common look and feel\n\n\nfollow a consistent RESTful style and syntax\n\n\n\n\nBased on your concrete customer use cases, you should carefully check the trade-offs of API design variants and avoid short-term server side implementation optimizations at the expense of unnecessary client side obligations and have a high attention on API quality and client developer experience.\n\n\nAPI as a Product is closely related to our API First principle (see next chapter) which is more focussed on how we engineer high quality APIs.\n\n\nAPI Design Principles\n\n\nREST is centered around business (data) entities exposed as resources that are identified via URIs and can be manipulated via standardized CRUD-like methods using different representations, self-descriptive messages and hypermedia. RESTful APIs tend to be less use-case specific and comes with less rigid client / server coupling and are more suitable as a platform interface being open for diverse client applications.\n\n\n\n\nWe prefer REST-based APIs with JSON payloads\n\n\nWe prefer systems to be truly RESTful\n\n\nWe apply the RESTful web service principles to all kind of application components, whether they provide functionality via the Internet or via the intranet as larger application elements.\n\n\nWe strive to build interoperating distributed systems that different teams can evolve in parallel.\n\n\n\n\nAn important principle for (RESTful) API design and usage is Postel's Law, aka the Robustness Principle\n\n\n\n\nBe liberal in what you accept, be conservative in what you send\n\n\n\n\nReadings: Read the following to gain additional insight on the RESTful service architecture paradigm and general RESTful API design style:\n\n\nSecurity\n\n\nTODO", 
            "title": "Guidelines"
        }, 
        {
            "location": "/design-principles/guidelines/#api-as-a-product", 
            "text": "We are transforming to a platform comprising a rich set of products following a Software as a Platform (SaaS) model for our business partners. We want to deliver products to our customers which can be consumed like a service.  Platform products provide their functionality via (public) APIs; hence, the design of our APIs should be based on the API as a Product principle:   Treat your API as product and understand the needs of its customers  Take ownership and advocate for the customer and continuous improvement  Emphasize easy understanding, discovery and usage of APIs; design APIs irresistible for client engineers  Actively improve and maintain API consistency over the long term  Make use of customer feedback and provide service level support  RESTful API as a Product makes the difference between enterprise integration business and agile, innovative product service business built on a platform of APIs.  are easy to understand and learn  are general and abstracted from specific implementation and use cases  have a common look and feel  follow a consistent RESTful style and syntax   Based on your concrete customer use cases, you should carefully check the trade-offs of API design variants and avoid short-term server side implementation optimizations at the expense of unnecessary client side obligations and have a high attention on API quality and client developer experience.  API as a Product is closely related to our API First principle (see next chapter) which is more focussed on how we engineer high quality APIs.", 
            "title": "API as a Product"
        }, 
        {
            "location": "/design-principles/guidelines/#api-design-principles", 
            "text": "REST is centered around business (data) entities exposed as resources that are identified via URIs and can be manipulated via standardized CRUD-like methods using different representations, self-descriptive messages and hypermedia. RESTful APIs tend to be less use-case specific and comes with less rigid client / server coupling and are more suitable as a platform interface being open for diverse client applications.   We prefer REST-based APIs with JSON payloads  We prefer systems to be truly RESTful  We apply the RESTful web service principles to all kind of application components, whether they provide functionality via the Internet or via the intranet as larger application elements.  We strive to build interoperating distributed systems that different teams can evolve in parallel.   An important principle for (RESTful) API design and usage is Postel's Law, aka the Robustness Principle   Be liberal in what you accept, be conservative in what you send   Readings: Read the following to gain additional insight on the RESTful service architecture paradigm and general RESTful API design style:", 
            "title": "API Design Principles"
        }, 
        {
            "location": "/design-principles/guidelines/#security", 
            "text": "TODO", 
            "title": "Security"
        }, 
        {
            "location": "/design-principles/object-props/", 
            "text": "Object Guidelines\n\n\nProperty Names\n\n\n\n\nbe consistent\n\n\nproperty names must be camelCase\n\n\nProperty names must be an ASCII subset. The first character must be a letter, an underscore or a dollar sign, and subsequent characters can be a letter, an underscore, hyphen or a number.\n\n\nArray and collection names should be pluralized\n\n\nUse Consistent Property Values\n\n\nBoolean property values must not be null and have a default, which means they are always shown but never required\n\n\n\n\nNull values should have their fields removed\n  Swagger/OpenAPI, which is in common use, doesn't support null field values (it does allow omitting that field completely if it is not marked as required). However that doesn't prevent clients and servers sending and receiving those fields with null values. Also, in some cases null may be a meaningful value - for example, JSON Merge Patch RFC 7382) using null to indicate property deletion.\n\n\n\n\n\n\nEmpty array values should not be null, they can be represented as the the empty list, [].\n\n\n\n\nEnumerations should be represented as Strings\n\n\nDate and date-time property values should conform to RFC 3399\n\n\nfor \"date\" use strings matching date-fullyear \"-\" date-month \"-\" date-mday, for example: 2015-05-28\n\n\nfor \"date-time\" use strings matching full-date \"T\" full-time, for example 2015-05-28T14:07:17Z\n\n\n\n\nA zone offset may be used (both, in request and responses) -- this is simply defined by the standards. However, we encourage restricting dates to UTC and without offsets. For example 2015-05-28T14:07:17Z rather than 2015-05-28T14:07:17+00:00. From experience we have learned that zone offsets are not easy to understand and often not correctly handled. Note also that zone offsets are different from local times that might be including daylight saving time. Localization of dates should be done by the services that provide user interfaces, if required.\n\n\n\n\n\n\nWhen it comes to storage, all dates should be consistently stored in UTC without a zone offset. Localization should be done locally by the services that provide user interfaces, if required.\n\n\n\n\n\n\nSchema based JSON properties that are by design durations and intervals could be strings formatted as recommended by ISO 8601 (Appendix A of RFC 3399 contains a grammar for durations).\n\n\n\n\n\n\nStandards should be used for Language, Country and Currency\n\n\n\n\n\n\nISO 3166-1-alpha2 country (It's \"GB\", not \"UK\",\nISO 639-1 language code\nBCP-47 (based on ISO 639-1) for language variants\nISO 4217 currency codes\n\n\nNaming\n\n\n\n\n\n\nPrefer to use lowercase separate words with hyphens for URI Path Segments. camelCase is ok but not ideal.\nsee \nhttp://www.tothenew.com/blog/customizing-url-formats-in-grails/\n and grails.web.url.converter yml property\n\nExample:\n\n/shipment-order/1/shipment-order-lines\nThis applies to concrete path segments and not the names of path parameters. For example shipment_order_id would be ok as a path parameter.\n\nsee here\n for a good explanation on case\n\n\n\n\n\n\ncamelCase or snake_case for Query Parameters\n\n\n\n\n\n\nPrefer Hyphenated-Pascal-Case for HTTP header Fields\n\n\n\n\n\n\nDo not Pluralize Resource Names, keep them the same as controller or use hyphens instead of camelCase if desired.\n\n\n\n\n\n\nMay: Use /api as first Path Segment\n\n\n\n\n\n\nMust: Avoid Trailing Slashes\n\n\n\n\n\n\nMay: Use Conventional Query Strings\n\n\n\n\n\n\nIf you provide query support for sorting, pagination, filtering functions or other actions, use the following standardized naming conventions:\n\n\n\n\nq\n \u2014 default query parameter (e.g. used by browser tab completion); should have an entity specific alias, like sku\n\n\nlimit\n \u2014 to restrict the number of entries. See Pagination section. Hint: You can use size as an alternate query string.\n\n\ncursor\n \u2014 key-based page start. See Pagination section below.\n\n\noffset\n \u2014 numeric offset page start. See Pagination section below. Hint: In combination with limit, you can use \npage\n as an alternative to offset.\n\n\nsort\n \u2014 comma-separated list of fields to sort. To indicate sorting direction, fields my prefixed with + (ascending) or - (descending, default), e.g. /sales-orders?sort=+id\n\n\nfields\n \u2014 to retrieve a subset of fields. See Support Filtering of Resource Fields below.\n\n\nexpand\n \u2014 to expand embedded entities (ie.: inside of an article entity, expand silhouette code into the silhouette object). Implementing \u201cexpand\u201d correctly is difficult, so do it with care. See Embedding resources for more details.", 
            "title": "Object, Naming, Props"
        }, 
        {
            "location": "/design-principles/object-props/#object-guidelines", 
            "text": "", 
            "title": "Object Guidelines"
        }, 
        {
            "location": "/design-principles/object-props/#property-names", 
            "text": "be consistent  property names must be camelCase  Property names must be an ASCII subset. The first character must be a letter, an underscore or a dollar sign, and subsequent characters can be a letter, an underscore, hyphen or a number.  Array and collection names should be pluralized  Use Consistent Property Values  Boolean property values must not be null and have a default, which means they are always shown but never required   Null values should have their fields removed\n  Swagger/OpenAPI, which is in common use, doesn't support null field values (it does allow omitting that field completely if it is not marked as required). However that doesn't prevent clients and servers sending and receiving those fields with null values. Also, in some cases null may be a meaningful value - for example, JSON Merge Patch RFC 7382) using null to indicate property deletion.    Empty array values should not be null, they can be represented as the the empty list, [].   Enumerations should be represented as Strings  Date and date-time property values should conform to RFC 3399  for \"date\" use strings matching date-fullyear \"-\" date-month \"-\" date-mday, for example: 2015-05-28  for \"date-time\" use strings matching full-date \"T\" full-time, for example 2015-05-28T14:07:17Z   A zone offset may be used (both, in request and responses) -- this is simply defined by the standards. However, we encourage restricting dates to UTC and without offsets. For example 2015-05-28T14:07:17Z rather than 2015-05-28T14:07:17+00:00. From experience we have learned that zone offsets are not easy to understand and often not correctly handled. Note also that zone offsets are different from local times that might be including daylight saving time. Localization of dates should be done by the services that provide user interfaces, if required.    When it comes to storage, all dates should be consistently stored in UTC without a zone offset. Localization should be done locally by the services that provide user interfaces, if required.    Schema based JSON properties that are by design durations and intervals could be strings formatted as recommended by ISO 8601 (Appendix A of RFC 3399 contains a grammar for durations).    Standards should be used for Language, Country and Currency    ISO 3166-1-alpha2 country (It's \"GB\", not \"UK\",\nISO 639-1 language code\nBCP-47 (based on ISO 639-1) for language variants\nISO 4217 currency codes", 
            "title": "Property Names"
        }, 
        {
            "location": "/design-principles/object-props/#naming", 
            "text": "Prefer to use lowercase separate words with hyphens for URI Path Segments. camelCase is ok but not ideal.\nsee  http://www.tothenew.com/blog/customizing-url-formats-in-grails/  and grails.web.url.converter yml property \nExample: \n/shipment-order/1/shipment-order-lines\nThis applies to concrete path segments and not the names of path parameters. For example shipment_order_id would be ok as a path parameter. see here  for a good explanation on case    camelCase or snake_case for Query Parameters    Prefer Hyphenated-Pascal-Case for HTTP header Fields    Do not Pluralize Resource Names, keep them the same as controller or use hyphens instead of camelCase if desired.    May: Use /api as first Path Segment    Must: Avoid Trailing Slashes    May: Use Conventional Query Strings    If you provide query support for sorting, pagination, filtering functions or other actions, use the following standardized naming conventions:   q  \u2014 default query parameter (e.g. used by browser tab completion); should have an entity specific alias, like sku  limit  \u2014 to restrict the number of entries. See Pagination section. Hint: You can use size as an alternate query string.  cursor  \u2014 key-based page start. See Pagination section below.  offset  \u2014 numeric offset page start. See Pagination section below. Hint: In combination with limit, you can use  page  as an alternative to offset.  sort  \u2014 comma-separated list of fields to sort. To indicate sorting direction, fields my prefixed with + (ascending) or - (descending, default), e.g. /sales-orders?sort=+id  fields  \u2014 to retrieve a subset of fields. See Support Filtering of Resource Fields below.  expand  \u2014 to expand embedded entities (ie.: inside of an article entity, expand silhouette code into the silhouette object). Implementing \u201cexpand\u201d correctly is difficult, so do it with care. See Embedding resources for more details.", 
            "title": "Naming"
        }, 
        {
            "location": "/design-principles/http-method-mapping/", 
            "text": "Resources\n\n\n\n\n\"A resource is anything that's important enough to be referenced as a thing in itself.\" Richardson and Ruby\n\n\n\n\nMust: Avoid Actions \u2014 Think About Resources\n\n\nREST is all about your resources, so consider the domain entities that take part in web service interaction, and aim to model your API around these using the standard HTTP methods as operation indicators. For instance, if an application has to lock articles explicitly so that only one user may edit them, create an article lock with PUT or POST instead of using a lock action.\n\n\nRequest:\n\n\nPUT /article-locks/{articleId}\n\n\n\n\n\nThe added benefit is that you already have a service for browsing and filtering article locks.\n\n\nShould: Model complete business processes\n\n\nAn API should contain the complete business processes containing all resources representing the process. This enables clients to understand the business process, foster a consistent design of the business process, allow for synergies from description and implementation perspective, and eliminates implicit invisible dependencies between APIs.\n\n\nIn addition, it prevents services from being designed as thin wrappers around databases, which normally tends to shift business logic to the clients.\n\n\nShould: Define \nuseful\n resources\n\n\nAs a rule of thumb resources should be defined to cover 90% of all its client's use cases. A \nuseful\n resource should\ncontain as much information as necessary, but as little as possible. A great way to support the last 10% is to allow\nclients to specify their needs for more/less information by supporting filtering and\n\nembedding\n.\n\n\nMust: Keep URLs Verb-Free\n\n\nThe API describes resources, so the only place where actions should appear is in the HTTP methods.\nIn URLs, use only nouns. Instead of thinking of actions (verbs), it's often helpful to think about putting a message in a letter box: e.g., instead of having the verb \ncancel\n in the url, think of sending a message to cancel an order to the \ncancellations\n letter box on the server side.\n\n\nDeviations from REST\n\n\nVerbs we use\n\n\n\n\nIn some places in the API, we need to deviate from common REST guidelines. Completely removing verbs isn\u2019t possible for every request, especially those related to sending a campaign, firing off a correction. Although there are some RESTful workarounds we could use, often they can be more confusing than they are useful.\n\n\nTo address this, we break from REST architecture for certain actions. For example, to pause an Automation workflow, you would make a POST request to the /automations/{workflow_id}/emails/{id}/actions/pause endpoint. All verb based action endpoints should be namespaced this way. --source:MailChimp\n\n\n\n\nMust: Use Domain-Specific Resource Names\n\n\nAPI resources represent elements of the application\u2019s domain model. Using domain-specific nomenclature for resource names helps developers to understand the functionality and basic semantics of your resources. It also reduces the need for further documentation outside the API definition. For example, \u201csales-order-items\u201d is superior to \u201corder-items\u201d in that it clearly indicates which business object it represents. Along these lines, \u201citems\u201d is too general.\n\n\nMust: Identify resources and Sub-Resources via Path Segments\n\n\nSome API resources may contain or reference sub-resources. Embedded sub-resources, which are not top-level resources,\nare parts of a higher-level resource and cannot be used outside of its scope. Sub-resources should be referenced\nby their name and identifier in the path segments.\n\n\nComposite identifiers must not contain \u201c/\u201d as a separator. In order to improve the consumer experience, you should\naim for intuitively understandable URLs, where each sub-path is a valid reference to a resource or a set of resources.\nFor example, if \u201c/customers/12ev123bv12v/addresses/DE_100100101\u201d is a valid path of your API, then\n\u201c/customers/12ev123bv12v/addresses\u201d, \u201c/customers/12ev123bv12v\u201d and \u201c/customers\u201d must be valid as well in principle.\n\n\nBasic URL structure:\n\n\n/{resources}/[resource-id]/{sub-resources}/[sub-resource-id]\n/{resources}/[partial-id-1][separator][partial-id-2]\n\n\n\n\n\nExamples:\n\n\n/carts/1681e6b88ec1/items\n/carts/1681e6b88ec1/items/1\n/customers/12ev123bv12v/addresses/DE_100100101\n\n\n\n\n\nShould: Limit number of Resources\n\n\nTo keep maintenance and service evolution manageable, we should follow \"functional segmentation\" and \"separation of concern\" design principles and do not mix different business functionalities in same API definition. In this sense the number of resources exposed via API should be limited - our experience is that a typical range of resources for a well-designed API is between 4 and 8. There may be exceptions with more complex business domains that require more resources, but you should first check if you can split them into separate subdomains with distinct APIs.\n\n\nNevertheless one API should hold all necessary resources to model complete business processes helping clients to understand these flows.\n\n\nShould: Limit number of Sub-Resource Levels\n\n\nThere are main resources (with root url paths) and sub-resources (or \u201cnested\u201d resources with non-root urls paths). Use sub-resources if their life cycle is (loosely) coupled to the main resource, i.e. the main resource works as collection resource of the subresource entities. You should use \n= 3 sub-resource (nesting) levels -- more levels increase API complexity and url path length. (Remember, some popular web browsers do not support URLs of more than 2000 characters)\n\n\nUse HTTP Methods Correctly\n\n\nBe compliant with the standardized HTTP method semantics summarized as follows:\n\n\nGET\n\n\nGET requests are used to read a single resource or query set of resources.\n\n\n\n\nGET requests for individual resources will usually generate a 404 if the resource does not exist\n\n\nGET requests for collection resources may return either 200 (if the listing is empty) or 404 (if\n  the list is missing)\n\n\nGET requests must NOT have request body payload\n\n\n\n\n\n\n GET requests on collection resources should provide a sufficient filter mechanism as well\nas \npagination\n.\n\n\n\n\nGET with Body\n\n\nAPIs sometimes face the problem, that they have to provide extensive structured request information\nwith GET, that may even conflicts with the size limits of clients, load-balancers, and servers. As\nwe require APIs to be standard conform (body in GET must be ignored on server side), API designers\nhave to check the following two options:\n\n\n\n\nGET with URL encoded query parameters: when it is possible to encode the request information in\n   query parameters, respecting the usual size limits of clients, gateways, and servers, this should\n   be the first choice. The request information can either be provided distributed to multiple query\n   parameters or a single structured URL encoded string.\n\n\nPOST with body content: when a GET with URL encoded query parameters is not possible, a POST with\n   body content must be used. In this case the endpoint must be documented with  the hint \nGET with\n   body\n to transport the GET semantic of this call.\n\n\n\n\n\n\n It is no option to encode the lengthy structured request information in header parameters.\nFrom a conceptual point of view, the semantic of an operation should always be expressed by resource\nname and query parameters, i.e. what goes into the URL. Request headers are reserved for general\ncontext information, e.g. FlowIDs. In addition, size limits on query parameters and headers are not\nreliable and depend on clients, gateways, server, and actual settings. Thus, switching to headers\ndoes not solve the original problem.\n\n\n\n\nPUT\n\n\nPUT requests are used to create or update \nentire\n resources - single or collection resources. The\nsemantic is best described as \u00bb\nplease put the enclosed representation at the resource mentioned by\nthe URL, replacing any existing resource.\n\u00ab.\n\n\n\n\nPUT requests are usually applied to single resources, and not to collection resources, as this\n  would imply replacing the entire collection\n\n\nPUT requests are usually robust against non-existence of resources by implicitly creating before\n  updating\n\n\non successful PUT requests, the server will \nreplace the entire resource\n addressed by the URL\n  with the representation passed in the payload (subsequent reads will deliver the same payload)\n\n\nsuccessful PUT requests will usually generate 200 or 204 (if the resource was updated - with or\n  without actual content returned), and 201 (if the resource was created)\n\n\n\n\n\n\n Resource IDs with respect to PUT requests are maintained by the client and passed as a\nURL path segment. Putting the same resource twice is required to be idempotent and to result in\nthe same single resource instance. If PUT is applied for creating a resource, only URIs should be\nallowed as resource IDs. If URIs are not available POST should be preferred.\n\n\n\n\nTo prevent unnoticed concurrent updates when using PUT, the combination of \nETag\n and\n\nIf-(None-)Match\n\nheaders should be considered to signal the server stricter demands to expose conflicts and prevent\nlost updates.\n\n\nPOST\n\n\nPOST requests are idiomatically used to create single resources on a collection resource endpoint,\nbut other semantics on single resources endpoint are equally possible. The semantic for collection\nendpoints is best described as \u00bb\nplease add the enclosed representation to the collection resource\nidentified by the URL\n\u00ab. The semantic for single resource endpoints is best described as \u00bb\nplease\nexecute the given well specified request on the collection resource identified by the URL\n\u00ab.\n\n\n\n\nPOST request should only be applied to collection resources, and normally not on single resource,\n  as this has an undefined semantic\n\n\non successful POST requests, the server will create one or multiple new resources and provide\n  their URI/URLs in the response\n\n\nsuccessful POST requests will usually generate 200 (if resources have been updated), 201 (if\n  resources have been created), and 202 (if the request was accepted but has not been finished yet)\n\n\n\n\n\n\n POST should be used for scenarios that cannot be covered by the other methods\nsufficiently. For instance, GET with complex (e.g. SQL like structured) query that needs to be\npassed as request body payload because of the URL-length constraint. In such cases, make sure to\ndocument the fact that POST is used as a workaround.\n\n\n\n\n\n\n\n\n  \nResource IDs\n with respect to POST requests are created and maintained by server and\nreturned with response payload. Posting the same resource twice is by itself \nnot\n required to\nbe idempotent and may result in multiple resource instances. Anyhow, if external URIs are present\nthat can be used to identify duplicate requests, it is best practice to implement POST in an\nidempotent way.\n\n\n\n\nPATCH\n\n\nPATCH request are only used for partial update of single resources, i.e. where only a specific\nsubset of resource fields should be replaced. The semantic is best described as \u00bb\nplease change\nthe resource identified by the URL according to my change request\n\u00ab. The semantic of the change\nrequest is not defined in the HTTP standard and must be described in the API specification by\nusing suitable media types.\n\n\n\n\nPATCH requests are usually applied to single resources, and not on collection resources, as this\n  would imply patching on the entire collection\n\n\nPATCH requests are usually not robust against non-existence of resource instances\n\n\non successful PATCH requests, the server will update parts of the resource addressed by the URL\n  as defined by the change request in the payload\n\n\nsuccessful PATCH requests will usually generate 200 or 204 (if resources have been updated\n\n\nwith or without updated content returned)\n\n\n\n\n\n\n since implementing PATCH correctly is a bit tricky, we strongly suggest to choose one and\nonly one of the following patterns per endpoint, unless forced by a \nbackwards compatible change\n. In preference order:\n\n\n\n\n\n\nuse PUT with complete objects to update a resource as long as feasible (i.e. do not use PATCH\n   at all).\n\n\nuse PATCH with partial objects to only update parts of a resource, when ever possible. (This is\n   basically  \nJSON Merge Patch\n, a specialized media type\n   \napplication/merge-patch+json\n that is a partial resource representation.)\n\n\nuse PATCH with \nJSON Patch\n, a specialized media type\n   \napplication/json-patch+json\n that includes instructions on how to change the resource.\n\n\nuse POST (with a proper description of what is happening) instead of PATCH if the request does\n   not modify the resource in a way defined by the semantics of the media type.\n\n\n\n\nIn practice \nJSON Merge Patch\n quickly turns out to be too\nlimited, especially when trying to update single objects in large collections (as part of the\nresource). In this cases \nJSON Patch\n can shown its full power\nwhile still showing readable patch requests\n(\nsee also\n).\n\n\nTo prevent unnoticed concurrent updates when using PATCH, the combination of \nETag\n and\n\nIf-Match\n\nheaders should be considered to signal the server stricter demands to expose conflicts and prevent\nlost updates.\n\n\nPut vs Patch. \n* \nhttps://stackoverflow.com/questions/28459418/rest-api-put-vs-patch-with-real-life-examples\n \n* \n\n\nDELETE\n\n\nDELETE request are used to delete resources. The semantic is best described as \u00bb\nplease delete the\nresource identified by the URL\n\u00ab.\n\n\n\n\nDELETE requests are usually applied to single resources, not on collection resources, as this\n  would imply deleting the entire collection\n\n\nsuccessful DELETE request will usually generate 200 (if the deleted resource is returned) or 204\n  (if no content is returned)\n\n\nfailed DELETE request will usually generate 404 (if the resource cannot be found) or 410 (if the\n  resource was already deleted before)\n\n\n\n\nHEAD\n\n\nHEAD requests are used retrieve to header information of single resources and resource collections.\n\n\n\n\nHEAD has exactly the same semantics as GET, but returns headers only, no body.\n\n\n\n\nOPTIONS\n\n\nOPTIONS are used to inspect the available operations (HTTP methods) of a given endpoint.\n\n\n\n\nOPTIONS requests usually either return a comma separated list of methods (provided by an\n  \nAllow:\n-Header) or as a structured list of link templates\n\n\n\n\n\n\n  OPTIONS is rarely implemented, though it could be used to self-describe the full\nfunctionality of a resource.\n\n\n\n\nDeviations from REST\n\n\nVerbs we use\n\n\n\n\nIn some places in the API, we need to deviate from common REST guidelines. Completely removing verbs isn\u2019t possible for every request, especially those related to sending a campaign, firing off a correction. Although there are some RESTful workarounds we could use, often they can be more confusing than they are useful.\n\n\nTo address this, we break from REST architecture for certain actions. For example, to pause an Automation workflow, you would make a POST request to the /automations/{workflow_id}/emails/{id}/actions/pause endpoint. All action endpoints are namespaced this way. --source:MailChimp\n\n\n\n\nFulfill Safeness and Idempotency Properties\n\n\nAn operation can be...\n\n\n\n\nidempotent, i.e. operation will produce the same results if executed once or multiple times (note: this does not\n  necessarily mean returning the same status code)\n\n\nsafe, i.e. must not have side effects such as state changes\n\n\n\n\nMethod implementations must fulfill the following basic properties:\n\n\n\n\n\n\n\n\nHTTP method\n\n\nsafe\n\n\nidempotent\n\n\n\n\n\n\n\n\n\n\nOPTIONS\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nHEAD\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nGET\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nPUT\n\n\nNo\n\n\nYes\n\n\n\n\n\n\nPOST\n\n\nNo\n\n\nNo\n\n\n\n\n\n\nDELETE\n\n\nNo\n\n\nYes\n\n\n\n\n\n\nPATCH\n\n\nNo\n\n\nNo\n\n\n\n\n\n\n\n\nPlease see also \nBest Practices [internal link]\n for further hints on how to support the\ndifferent HTTP methods on resources.\n\n\nUse Specific HTTP Status Codes\n\n\nThis guideline groups the following rules for HTTP status codes usage:\n\n\n\n\nYou must not invent new HTTP status codes; only use standardized HTTP status codes and consistent with its intended semantics.\n\n\nYou should use the most specific HTTP status code for your concrete resource request processing status or error situation.\n\n\nYou should provide good documentation in the API definition when using HTTP status codes that are less commonly used and not listed below.  \n\n\n\n\nThere are ~60 different HTTP status codes with specific semantics defined in the HTTP standards (mainly \nRFC7231\n and \nRFC-6585\n) - and there are upcoming new ones, e.g. \ndraft legally-restricted-status\n (see overview on all error codes on \nWikipedia\n or via \nhttps://httpstatuses.com/\n). And there are unofficial ones, e.g. used by specific web servers like Nginx.  \n\n\nOur list of most commonly used and best understood HTTP status codes:\n\n\nSuccess Codes\n\n\n\n\n\n\n\n\nCode\n\n\nMeaning\n\n\nMethods\n\n\n\n\n\n\n\n\n\n\n200\n\n\nOK - this is the standard success response\n\n\nAll\n\n\n\n\n\n\n201\n\n\nCreated - Returned on successful entity creation. You are free to return either an empty response or the created resource in conjunction with the Location header. (More details found in the \nCommon Headers section\n.) \nAlways\n set the Location header.\n\n\nPOST, PUT\n\n\n\n\n\n\n202\n\n\nAccepted - The request was successful and will be processed asynchronously.\n\n\nPOST, PUT, DELETE, PATCH\n\n\n\n\n\n\n204\n\n\nNo content - There is no response body\n\n\nPUT, DELETE\n\n\n\n\n\n\n207\n\n\nMulti-Status - The response body contains multiple status informations for different parts of a batch/bulk request. See \n\"Use 207 for Batch or Bulk Requests\"\n.\n\n\nPOST\n\n\n\n\n\n\n\n\nRedirection Codes\n\n\n\n\n\n\n\n\nCode\n\n\nMeaning\n\n\nMethods\n\n\n\n\n\n\n\n\n\n\n301\n\n\nMoved Permanently - This and all future requests should be directed to the given URI.\n\n\nAll\n\n\n\n\n\n\n303\n\n\nSee Other - The response to the request can be found under another URI using a GET method.\n\n\nPATCH, POST, PUT, DELETE\n\n\n\n\n\n\n304\n\n\nNot Modified - resource has not been modified since the date or version passed via request headers If-Modified-Since or If-None-Match.\n\n\nGET\n\n\n\n\n\n\n\n\nClient Side Error Codes\n\n\n\n\n\n\n\n\nCode\n\n\nMeaning\n\n\nMethods\n\n\n\n\n\n\n\n\n\n\n400\n\n\nBad request - generic / unknown error\n\n\nAll\n\n\n\n\n\n\n401\n\n\nUnauthorized - the users must log in (this often means \u201cUnauthenticated\u201d)\n\n\nAll\n\n\n\n\n\n\n403\n\n\nForbidden - the user is not authorized to use this resource\n\n\nAll\n\n\n\n\n\n\n404\n\n\nNot found - the resource is not found\n\n\nAll\n\n\n\n\n\n\n405\n\n\nMethod Not Allowed - the method is not supported, see OPTIONS\n\n\nAll\n\n\n\n\n\n\n406\n\n\nNot Acceptable - resource can only generate content not acceptable according to the Accept headers sent in the request\n\n\nAll\n\n\n\n\n\n\n408\n\n\nRequest timeout - the server times out waiting for the resource\n\n\nAll\n\n\n\n\n\n\n409\n\n\nConflict - request cannot be completed due to conflict, e.g. when two clients try to create the same resource or if there are concurrent, conflicting updates\n\n\nPUT, DELETE, PATCH\n\n\n\n\n\n\n410\n\n\nGone - resource does not exist any longer, e.g. when accessing a resource that has intentionally been deleted\n\n\nAll\n\n\n\n\n\n\n412\n\n\nPrecondition Failed - returned for conditional requests, e.g. If-Match if the condition failed. Used for optimistic locking.\n\n\nPUT, DELETE, PATCH\n\n\n\n\n\n\n415\n\n\nUnsupported Media Type - e.g. clients sends request body without content type\n\n\nPUT, DELETE, PATCH\n\n\n\n\n\n\n423\n\n\nLocked - Pessimistic locking, e.g. processing states\n\n\nPUT, DELETE, PATCH\n\n\n\n\n\n\n428\n\n\nPrecondition Required - server requires the request to be conditional (e.g. to make sure that the \u201clost update problem\u201d is avoided).\n\n\nAll\n\n\n\n\n\n\n429\n\n\nToo many requests - the client does not consider rate limiting and sent too many requests. See \n\"Use 429 with Headers for Rate Limits\"\n.\n\n\nAll\n\n\n\n\n\n\n\n\nServer Side Error Codes:\n\n\n\n\n\n\n\n\nCode\n\n\nMeaning\n\n\nMethods\n\n\n\n\n\n\n\n\n\n\n500\n\n\nInternal Server Error - a generic error indication for an unexpected server execution problem (here, client retry may be senseful)\n\n\nAll\n\n\n\n\n\n\n501\n\n\nNot Implemented -  server cannot fulfill the request (usually implies future availability, e.g. new feature).\n\n\nAll\n\n\n\n\n\n\n503\n\n\nService Unavailable - server is (temporarily) not available (e.g. due to overload) -- client retry may be senseful.\n\n\nAll\n\n\n\n\n\n\n\n\nProvide Error Documentation\n\n\nAPIs should define the functional, business view and abstract from implementation aspects. Errors become a key element providing context and visibility into how to use an API. The error object should be extended by an application-specific error identifier if and only if the HTTP status code is not specific enough to convey the domain-specific error semantic. For this reason, we use a standardized error return object definition \u2014 see \nUse Common Error Return Objects\n.\n\n\nThe OpenAPI specification shall include definitions for error descriptions that will be returned; they are part of the interface definition and provide important information for service clients to handle exceptional situations and support troubleshooting. You should also think about a troubleshooting board \u2014 it is part of the associated online API documentation, provides information and handling guidance on application-specific errors and is referenced via links of the API definition. This can reduce service support tasks and contribute to service client and provider performance.\n\n\nService providers should differentiate between technical and functional errors. In most cases it's not useful to document technical errors that are not in control of the service provider unless the status code convey application-specific semantics. The list of status code that can be omitted from API specifications includes but is not limited to:\n\n\n\n\n401 Unauthorized\n\n\n403 Forbidden\n\n\n404 Not Found\n unless it has some additional semantics\n\n\n405 Method Not Allowed\n\n\n406 Not Acceptable\n\n\n408 Request Timeout\n\n\n413 Payload Too Large\n\n\n414 URI Too Long\n\n\n415 Unsupported Media Type\n\n\n500 Internal Server Error\n\n\n502 Bad Gateway\n\n\n503 Service Unavailable\n\n\n504 Gateway Timeout\n\n\n\n\nEven though they might not be documented - they may very much occur in production, so clients should be prepared for unexpected response codes, and in case of doubt handle them like they would handle the corresponding x00 code. Adding new response codes (specially error responses) should be considered a compatible API evolution.\n\n\nFunctional errors on the other hand, that convey domain-specific semantics, must be documented and are strongly encouraged to be expressed with \nProblem types\n.\n\n\nUse 207 for Batch or Bulk Requests\n\n\nSome APIs are required to provide either \nbatch\n or \nbulk\n requests using POST for performance reasons, i.e. for communication and processing efficiency. In this case services may be in need to signal multiple response codes for each part of an batch or bulk request. As HTTP does not provide proper guidance for handling batch/bulk requests and responses, we herewith define the following approach:\n\n\n\n\nA batch or bulk request \nalways\n has to respond with HTTP status code \n207\n, unless it encounters a generic or unexpected failure before looking at individual parts.\n\n\nA batch or bulk response with status code 207 \nalways\n returns a multi-status object containing sufficient status and/or monitoring information for each part of the batch or bulk request.\n\n\nA batch or bulk request may result in a status code 400/500, only if the service encounters a failure before looking at individual parts or, if an unanticipated failure occurs.\n\n\n\n\nThe before rules apply \neven in the case\n that processing of all individual part \nfail\n or each part is executed \nasynchronously\n! They are intended to allow clients to act on batch and bulk responses by inspecting the individual results in a consistent way.\n\n\n\n\n \nwhile a \nbatch\n defines a collection of requests triggering independent processes, a \nbulk\n defines a collection of independent resources created or updated together in one request. With respect to response processing this distinction normally does not matter.\n\n\n\n\nUse 429 with Headers for Rate Limits\n\n\nAPIs that wish to manage the request rate of clients must use the \n'429 Too Many Requests'\n response code if the client exceeded the request rate and therefore the request can't be fulfilled. Such responses must also contain header information providing further details to the client. There are two approaches a service can take for header information:\n\n\n\n\n\n\nReturn a \n'Retry-After'\n header indicating how long the client ought to wait before making a follow-up request. The Retry-After header can contain a HTTP date value to retry after or the number of seconds to delay. Either is acceptable but APIs should prefer to use a delay in seconds.\n\n\n\n\n\n\nReturn a trio of 'X-RateLimit' headers. These headers (described below) allow a server to express a service level in the form of a number of allowing requests within a given window of time and when the window is reset.\n\n\n\n\n\n\nThe 'X-RateLimit' headers are:\n\n\n\n\nX-RateLimit-Limit\n: The maximum number of requests that the client is allowed to make in this window.\n\n\nX-RateLimit-Remaining\n: The number of requests allowed in the current window.\n\n\nX-RateLimit-Reset\n: The relative time in seconds when the rate limit window will be reset.\n\n\n\n\nThe reason to allow both approaches is that APIs can have different needs. Retry-After is often sufficient for general load handling and request throttling scenarios and notably, does not strictly require the concept of a calling entity such as a tenant or named account. In turn this allows resource owners to minimise the amount of state they have to carry with respect to client requests. The 'X-RateLimit' headers are suitable for scenarios where clients are associated with pre-existing account or tenancy structures. 'X-RateLimit' headers are generally returned on every request and not just on a 429, which implies the service implementing the API is carrying sufficient state to track the number of requests made within a given window for each named entity.\n\n\nExplicitly define the Collection Format of Query Parameters\n\n\nThere are different ways of supplying a set of values as a query parameter.\nOne particular type should be selected and stated explicitly in the API definition.\nThe OpenAPI property \ncollectionFormat\n is used to specify the format of the query parameter.\n\n\nOnly the \ncsv\n or \nmulti\n formats should be used for multi-value query parameters as described below.\n\n\n\n\n\n\n\n\nCollection Format\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\ncsv\n\n\nComma separated values\n\n\n?parameter=value1,value2,value3\n\n\n\n\n\n\nmulti\n\n\nMultiple parameter instances\n\n\n?parameter=value1\nparameter=value2\nparameter=value3\n\n\n\n\n\n\n\n\nWhen choosing the collection format, take into account the tool support, the escaping of special characters and the maximal URL length.", 
            "title": "Http Method Mapping"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#resources", 
            "text": "\"A resource is anything that's important enough to be referenced as a thing in itself.\" Richardson and Ruby", 
            "title": "Resources"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#must-avoid-actions-think-about-resources", 
            "text": "REST is all about your resources, so consider the domain entities that take part in web service interaction, and aim to model your API around these using the standard HTTP methods as operation indicators. For instance, if an application has to lock articles explicitly so that only one user may edit them, create an article lock with PUT or POST instead of using a lock action.  Request:  PUT /article-locks/{articleId}  The added benefit is that you already have a service for browsing and filtering article locks.", 
            "title": "Must: Avoid Actions \u2014 Think About Resources"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#should-model-complete-business-processes", 
            "text": "An API should contain the complete business processes containing all resources representing the process. This enables clients to understand the business process, foster a consistent design of the business process, allow for synergies from description and implementation perspective, and eliminates implicit invisible dependencies between APIs.  In addition, it prevents services from being designed as thin wrappers around databases, which normally tends to shift business logic to the clients.", 
            "title": "Should: Model complete business processes"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#should-define-useful-resources", 
            "text": "As a rule of thumb resources should be defined to cover 90% of all its client's use cases. A  useful  resource should\ncontain as much information as necessary, but as little as possible. A great way to support the last 10% is to allow\nclients to specify their needs for more/less information by supporting filtering and embedding .", 
            "title": "Should: Define useful resources"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#must-keep-urls-verb-free", 
            "text": "The API describes resources, so the only place where actions should appear is in the HTTP methods.\nIn URLs, use only nouns. Instead of thinking of actions (verbs), it's often helpful to think about putting a message in a letter box: e.g., instead of having the verb  cancel  in the url, think of sending a message to cancel an order to the  cancellations  letter box on the server side.", 
            "title": "Must: Keep URLs Verb-Free"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#deviations-from-rest", 
            "text": "Verbs we use   In some places in the API, we need to deviate from common REST guidelines. Completely removing verbs isn\u2019t possible for every request, especially those related to sending a campaign, firing off a correction. Although there are some RESTful workarounds we could use, often they can be more confusing than they are useful.  To address this, we break from REST architecture for certain actions. For example, to pause an Automation workflow, you would make a POST request to the /automations/{workflow_id}/emails/{id}/actions/pause endpoint. All verb based action endpoints should be namespaced this way. --source:MailChimp", 
            "title": "Deviations from REST"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#must-use-domain-specific-resource-names", 
            "text": "API resources represent elements of the application\u2019s domain model. Using domain-specific nomenclature for resource names helps developers to understand the functionality and basic semantics of your resources. It also reduces the need for further documentation outside the API definition. For example, \u201csales-order-items\u201d is superior to \u201corder-items\u201d in that it clearly indicates which business object it represents. Along these lines, \u201citems\u201d is too general.", 
            "title": "Must: Use Domain-Specific Resource Names"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#must-identify-resources-and-sub-resources-via-path-segments", 
            "text": "Some API resources may contain or reference sub-resources. Embedded sub-resources, which are not top-level resources,\nare parts of a higher-level resource and cannot be used outside of its scope. Sub-resources should be referenced\nby their name and identifier in the path segments.  Composite identifiers must not contain \u201c/\u201d as a separator. In order to improve the consumer experience, you should\naim for intuitively understandable URLs, where each sub-path is a valid reference to a resource or a set of resources.\nFor example, if \u201c/customers/12ev123bv12v/addresses/DE_100100101\u201d is a valid path of your API, then\n\u201c/customers/12ev123bv12v/addresses\u201d, \u201c/customers/12ev123bv12v\u201d and \u201c/customers\u201d must be valid as well in principle.  Basic URL structure:  /{resources}/[resource-id]/{sub-resources}/[sub-resource-id]\n/{resources}/[partial-id-1][separator][partial-id-2]  Examples:  /carts/1681e6b88ec1/items\n/carts/1681e6b88ec1/items/1\n/customers/12ev123bv12v/addresses/DE_100100101", 
            "title": "Must: Identify resources and Sub-Resources via Path Segments"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#should-limit-number-of-resources", 
            "text": "To keep maintenance and service evolution manageable, we should follow \"functional segmentation\" and \"separation of concern\" design principles and do not mix different business functionalities in same API definition. In this sense the number of resources exposed via API should be limited - our experience is that a typical range of resources for a well-designed API is between 4 and 8. There may be exceptions with more complex business domains that require more resources, but you should first check if you can split them into separate subdomains with distinct APIs.  Nevertheless one API should hold all necessary resources to model complete business processes helping clients to understand these flows.", 
            "title": "Should: Limit number of Resources"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#should-limit-number-of-sub-resource-levels", 
            "text": "There are main resources (with root url paths) and sub-resources (or \u201cnested\u201d resources with non-root urls paths). Use sub-resources if their life cycle is (loosely) coupled to the main resource, i.e. the main resource works as collection resource of the subresource entities. You should use  = 3 sub-resource (nesting) levels -- more levels increase API complexity and url path length. (Remember, some popular web browsers do not support URLs of more than 2000 characters)", 
            "title": "Should: Limit number of Sub-Resource Levels"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#use-http-methods-correctly", 
            "text": "Be compliant with the standardized HTTP method semantics summarized as follows:", 
            "title": "Use HTTP Methods Correctly"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#get", 
            "text": "GET requests are used to read a single resource or query set of resources.   GET requests for individual resources will usually generate a 404 if the resource does not exist  GET requests for collection resources may return either 200 (if the listing is empty) or 404 (if\n  the list is missing)  GET requests must NOT have request body payload     GET requests on collection resources should provide a sufficient filter mechanism as well\nas  pagination .", 
            "title": "GET"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#get-with-body", 
            "text": "APIs sometimes face the problem, that they have to provide extensive structured request information\nwith GET, that may even conflicts with the size limits of clients, load-balancers, and servers. As\nwe require APIs to be standard conform (body in GET must be ignored on server side), API designers\nhave to check the following two options:   GET with URL encoded query parameters: when it is possible to encode the request information in\n   query parameters, respecting the usual size limits of clients, gateways, and servers, this should\n   be the first choice. The request information can either be provided distributed to multiple query\n   parameters or a single structured URL encoded string.  POST with body content: when a GET with URL encoded query parameters is not possible, a POST with\n   body content must be used. In this case the endpoint must be documented with  the hint  GET with\n   body  to transport the GET semantic of this call.     It is no option to encode the lengthy structured request information in header parameters.\nFrom a conceptual point of view, the semantic of an operation should always be expressed by resource\nname and query parameters, i.e. what goes into the URL. Request headers are reserved for general\ncontext information, e.g. FlowIDs. In addition, size limits on query parameters and headers are not\nreliable and depend on clients, gateways, server, and actual settings. Thus, switching to headers\ndoes not solve the original problem.", 
            "title": "GET with Body"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#put", 
            "text": "PUT requests are used to create or update  entire  resources - single or collection resources. The\nsemantic is best described as \u00bb please put the enclosed representation at the resource mentioned by\nthe URL, replacing any existing resource. \u00ab.   PUT requests are usually applied to single resources, and not to collection resources, as this\n  would imply replacing the entire collection  PUT requests are usually robust against non-existence of resources by implicitly creating before\n  updating  on successful PUT requests, the server will  replace the entire resource  addressed by the URL\n  with the representation passed in the payload (subsequent reads will deliver the same payload)  successful PUT requests will usually generate 200 or 204 (if the resource was updated - with or\n  without actual content returned), and 201 (if the resource was created)     Resource IDs with respect to PUT requests are maintained by the client and passed as a\nURL path segment. Putting the same resource twice is required to be idempotent and to result in\nthe same single resource instance. If PUT is applied for creating a resource, only URIs should be\nallowed as resource IDs. If URIs are not available POST should be preferred.   To prevent unnoticed concurrent updates when using PUT, the combination of  ETag  and If-(None-)Match \nheaders should be considered to signal the server stricter demands to expose conflicts and prevent\nlost updates.", 
            "title": "PUT"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#post", 
            "text": "POST requests are idiomatically used to create single resources on a collection resource endpoint,\nbut other semantics on single resources endpoint are equally possible. The semantic for collection\nendpoints is best described as \u00bb please add the enclosed representation to the collection resource\nidentified by the URL \u00ab. The semantic for single resource endpoints is best described as \u00bb please\nexecute the given well specified request on the collection resource identified by the URL \u00ab.   POST request should only be applied to collection resources, and normally not on single resource,\n  as this has an undefined semantic  on successful POST requests, the server will create one or multiple new resources and provide\n  their URI/URLs in the response  successful POST requests will usually generate 200 (if resources have been updated), 201 (if\n  resources have been created), and 202 (if the request was accepted but has not been finished yet)     POST should be used for scenarios that cannot be covered by the other methods\nsufficiently. For instance, GET with complex (e.g. SQL like structured) query that needs to be\npassed as request body payload because of the URL-length constraint. In such cases, make sure to\ndocument the fact that POST is used as a workaround.        Resource IDs  with respect to POST requests are created and maintained by server and\nreturned with response payload. Posting the same resource twice is by itself  not  required to\nbe idempotent and may result in multiple resource instances. Anyhow, if external URIs are present\nthat can be used to identify duplicate requests, it is best practice to implement POST in an\nidempotent way.", 
            "title": "POST"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#patch", 
            "text": "PATCH request are only used for partial update of single resources, i.e. where only a specific\nsubset of resource fields should be replaced. The semantic is best described as \u00bb please change\nthe resource identified by the URL according to my change request \u00ab. The semantic of the change\nrequest is not defined in the HTTP standard and must be described in the API specification by\nusing suitable media types.   PATCH requests are usually applied to single resources, and not on collection resources, as this\n  would imply patching on the entire collection  PATCH requests are usually not robust against non-existence of resource instances  on successful PATCH requests, the server will update parts of the resource addressed by the URL\n  as defined by the change request in the payload  successful PATCH requests will usually generate 200 or 204 (if resources have been updated  with or without updated content returned)     since implementing PATCH correctly is a bit tricky, we strongly suggest to choose one and\nonly one of the following patterns per endpoint, unless forced by a  backwards compatible change . In preference order:    use PUT with complete objects to update a resource as long as feasible (i.e. do not use PATCH\n   at all).  use PATCH with partial objects to only update parts of a resource, when ever possible. (This is\n   basically   JSON Merge Patch , a specialized media type\n    application/merge-patch+json  that is a partial resource representation.)  use PATCH with  JSON Patch , a specialized media type\n    application/json-patch+json  that includes instructions on how to change the resource.  use POST (with a proper description of what is happening) instead of PATCH if the request does\n   not modify the resource in a way defined by the semantics of the media type.   In practice  JSON Merge Patch  quickly turns out to be too\nlimited, especially when trying to update single objects in large collections (as part of the\nresource). In this cases  JSON Patch  can shown its full power\nwhile still showing readable patch requests\n( see also ).  To prevent unnoticed concurrent updates when using PATCH, the combination of  ETag  and If-Match \nheaders should be considered to signal the server stricter demands to expose conflicts and prevent\nlost updates.  Put vs Patch. \n*  https://stackoverflow.com/questions/28459418/rest-api-put-vs-patch-with-real-life-examples  \n*", 
            "title": "PATCH"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#delete", 
            "text": "DELETE request are used to delete resources. The semantic is best described as \u00bb please delete the\nresource identified by the URL \u00ab.   DELETE requests are usually applied to single resources, not on collection resources, as this\n  would imply deleting the entire collection  successful DELETE request will usually generate 200 (if the deleted resource is returned) or 204\n  (if no content is returned)  failed DELETE request will usually generate 404 (if the resource cannot be found) or 410 (if the\n  resource was already deleted before)", 
            "title": "DELETE"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#head", 
            "text": "HEAD requests are used retrieve to header information of single resources and resource collections.   HEAD has exactly the same semantics as GET, but returns headers only, no body.", 
            "title": "HEAD"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#options", 
            "text": "OPTIONS are used to inspect the available operations (HTTP methods) of a given endpoint.   OPTIONS requests usually either return a comma separated list of methods (provided by an\n   Allow: -Header) or as a structured list of link templates      OPTIONS is rarely implemented, though it could be used to self-describe the full\nfunctionality of a resource.", 
            "title": "OPTIONS"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#deviations-from-rest_1", 
            "text": "Verbs we use   In some places in the API, we need to deviate from common REST guidelines. Completely removing verbs isn\u2019t possible for every request, especially those related to sending a campaign, firing off a correction. Although there are some RESTful workarounds we could use, often they can be more confusing than they are useful.  To address this, we break from REST architecture for certain actions. For example, to pause an Automation workflow, you would make a POST request to the /automations/{workflow_id}/emails/{id}/actions/pause endpoint. All action endpoints are namespaced this way. --source:MailChimp", 
            "title": "Deviations from REST"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#fulfill-safeness-and-idempotency-properties", 
            "text": "An operation can be...   idempotent, i.e. operation will produce the same results if executed once or multiple times (note: this does not\n  necessarily mean returning the same status code)  safe, i.e. must not have side effects such as state changes   Method implementations must fulfill the following basic properties:     HTTP method  safe  idempotent      OPTIONS  Yes  Yes    HEAD  Yes  Yes    GET  Yes  Yes    PUT  No  Yes    POST  No  No    DELETE  No  Yes    PATCH  No  No     Please see also  Best Practices [internal link]  for further hints on how to support the\ndifferent HTTP methods on resources.", 
            "title": "Fulfill Safeness and Idempotency Properties"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#use-specific-http-status-codes", 
            "text": "This guideline groups the following rules for HTTP status codes usage:   You must not invent new HTTP status codes; only use standardized HTTP status codes and consistent with its intended semantics.  You should use the most specific HTTP status code for your concrete resource request processing status or error situation.  You should provide good documentation in the API definition when using HTTP status codes that are less commonly used and not listed below.     There are ~60 different HTTP status codes with specific semantics defined in the HTTP standards (mainly  RFC7231  and  RFC-6585 ) - and there are upcoming new ones, e.g.  draft legally-restricted-status  (see overview on all error codes on  Wikipedia  or via  https://httpstatuses.com/ ). And there are unofficial ones, e.g. used by specific web servers like Nginx.    Our list of most commonly used and best understood HTTP status codes:", 
            "title": "Use Specific HTTP Status Codes"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#success-codes", 
            "text": "Code  Meaning  Methods      200  OK - this is the standard success response  All    201  Created - Returned on successful entity creation. You are free to return either an empty response or the created resource in conjunction with the Location header. (More details found in the  Common Headers section .)  Always  set the Location header.  POST, PUT    202  Accepted - The request was successful and will be processed asynchronously.  POST, PUT, DELETE, PATCH    204  No content - There is no response body  PUT, DELETE    207  Multi-Status - The response body contains multiple status informations for different parts of a batch/bulk request. See  \"Use 207 for Batch or Bulk Requests\" .  POST", 
            "title": "Success Codes"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#redirection-codes", 
            "text": "Code  Meaning  Methods      301  Moved Permanently - This and all future requests should be directed to the given URI.  All    303  See Other - The response to the request can be found under another URI using a GET method.  PATCH, POST, PUT, DELETE    304  Not Modified - resource has not been modified since the date or version passed via request headers If-Modified-Since or If-None-Match.  GET", 
            "title": "Redirection Codes"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#client-side-error-codes", 
            "text": "Code  Meaning  Methods      400  Bad request - generic / unknown error  All    401  Unauthorized - the users must log in (this often means \u201cUnauthenticated\u201d)  All    403  Forbidden - the user is not authorized to use this resource  All    404  Not found - the resource is not found  All    405  Method Not Allowed - the method is not supported, see OPTIONS  All    406  Not Acceptable - resource can only generate content not acceptable according to the Accept headers sent in the request  All    408  Request timeout - the server times out waiting for the resource  All    409  Conflict - request cannot be completed due to conflict, e.g. when two clients try to create the same resource or if there are concurrent, conflicting updates  PUT, DELETE, PATCH    410  Gone - resource does not exist any longer, e.g. when accessing a resource that has intentionally been deleted  All    412  Precondition Failed - returned for conditional requests, e.g. If-Match if the condition failed. Used for optimistic locking.  PUT, DELETE, PATCH    415  Unsupported Media Type - e.g. clients sends request body without content type  PUT, DELETE, PATCH    423  Locked - Pessimistic locking, e.g. processing states  PUT, DELETE, PATCH    428  Precondition Required - server requires the request to be conditional (e.g. to make sure that the \u201clost update problem\u201d is avoided).  All    429  Too many requests - the client does not consider rate limiting and sent too many requests. See  \"Use 429 with Headers for Rate Limits\" .  All", 
            "title": "Client Side Error Codes"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#server-side-error-codes", 
            "text": "Code  Meaning  Methods      500  Internal Server Error - a generic error indication for an unexpected server execution problem (here, client retry may be senseful)  All    501  Not Implemented -  server cannot fulfill the request (usually implies future availability, e.g. new feature).  All    503  Service Unavailable - server is (temporarily) not available (e.g. due to overload) -- client retry may be senseful.  All", 
            "title": "Server Side Error Codes:"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#provide-error-documentation", 
            "text": "APIs should define the functional, business view and abstract from implementation aspects. Errors become a key element providing context and visibility into how to use an API. The error object should be extended by an application-specific error identifier if and only if the HTTP status code is not specific enough to convey the domain-specific error semantic. For this reason, we use a standardized error return object definition \u2014 see  Use Common Error Return Objects .  The OpenAPI specification shall include definitions for error descriptions that will be returned; they are part of the interface definition and provide important information for service clients to handle exceptional situations and support troubleshooting. You should also think about a troubleshooting board \u2014 it is part of the associated online API documentation, provides information and handling guidance on application-specific errors and is referenced via links of the API definition. This can reduce service support tasks and contribute to service client and provider performance.  Service providers should differentiate between technical and functional errors. In most cases it's not useful to document technical errors that are not in control of the service provider unless the status code convey application-specific semantics. The list of status code that can be omitted from API specifications includes but is not limited to:   401 Unauthorized  403 Forbidden  404 Not Found  unless it has some additional semantics  405 Method Not Allowed  406 Not Acceptable  408 Request Timeout  413 Payload Too Large  414 URI Too Long  415 Unsupported Media Type  500 Internal Server Error  502 Bad Gateway  503 Service Unavailable  504 Gateway Timeout   Even though they might not be documented - they may very much occur in production, so clients should be prepared for unexpected response codes, and in case of doubt handle them like they would handle the corresponding x00 code. Adding new response codes (specially error responses) should be considered a compatible API evolution.  Functional errors on the other hand, that convey domain-specific semantics, must be documented and are strongly encouraged to be expressed with  Problem types .", 
            "title": "Provide Error Documentation"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#use-207-for-batch-or-bulk-requests", 
            "text": "Some APIs are required to provide either  batch  or  bulk  requests using POST for performance reasons, i.e. for communication and processing efficiency. In this case services may be in need to signal multiple response codes for each part of an batch or bulk request. As HTTP does not provide proper guidance for handling batch/bulk requests and responses, we herewith define the following approach:   A batch or bulk request  always  has to respond with HTTP status code  207 , unless it encounters a generic or unexpected failure before looking at individual parts.  A batch or bulk response with status code 207  always  returns a multi-status object containing sufficient status and/or monitoring information for each part of the batch or bulk request.  A batch or bulk request may result in a status code 400/500, only if the service encounters a failure before looking at individual parts or, if an unanticipated failure occurs.   The before rules apply  even in the case  that processing of all individual part  fail  or each part is executed  asynchronously ! They are intended to allow clients to act on batch and bulk responses by inspecting the individual results in a consistent way.     while a  batch  defines a collection of requests triggering independent processes, a  bulk  defines a collection of independent resources created or updated together in one request. With respect to response processing this distinction normally does not matter.", 
            "title": "Use 207 for Batch or Bulk Requests"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#use-429-with-headers-for-rate-limits", 
            "text": "APIs that wish to manage the request rate of clients must use the  '429 Too Many Requests'  response code if the client exceeded the request rate and therefore the request can't be fulfilled. Such responses must also contain header information providing further details to the client. There are two approaches a service can take for header information:    Return a  'Retry-After'  header indicating how long the client ought to wait before making a follow-up request. The Retry-After header can contain a HTTP date value to retry after or the number of seconds to delay. Either is acceptable but APIs should prefer to use a delay in seconds.    Return a trio of 'X-RateLimit' headers. These headers (described below) allow a server to express a service level in the form of a number of allowing requests within a given window of time and when the window is reset.    The 'X-RateLimit' headers are:   X-RateLimit-Limit : The maximum number of requests that the client is allowed to make in this window.  X-RateLimit-Remaining : The number of requests allowed in the current window.  X-RateLimit-Reset : The relative time in seconds when the rate limit window will be reset.   The reason to allow both approaches is that APIs can have different needs. Retry-After is often sufficient for general load handling and request throttling scenarios and notably, does not strictly require the concept of a calling entity such as a tenant or named account. In turn this allows resource owners to minimise the amount of state they have to carry with respect to client requests. The 'X-RateLimit' headers are suitable for scenarios where clients are associated with pre-existing account or tenancy structures. 'X-RateLimit' headers are generally returned on every request and not just on a 429, which implies the service implementing the API is carrying sufficient state to track the number of requests made within a given window for each named entity.", 
            "title": "Use 429 with Headers for Rate Limits"
        }, 
        {
            "location": "/design-principles/http-method-mapping/#explicitly-define-the-collection-format-of-query-parameters", 
            "text": "There are different ways of supplying a set of values as a query parameter.\nOne particular type should be selected and stated explicitly in the API definition.\nThe OpenAPI property  collectionFormat  is used to specify the format of the query parameter.  Only the  csv  or  multi  formats should be used for multi-value query parameters as described below.     Collection Format  Description  Example      csv  Comma separated values  ?parameter=value1,value2,value3    multi  Multiple parameter instances  ?parameter=value1 parameter=value2 parameter=value3     When choosing the collection format, take into account the tool support, the escaping of special characters and the maximal URL length.", 
            "title": "Explicitly define the Collection Format of Query Parameters"
        }, 
        {
            "location": "/design-principles/schema/", 
            "text": "Common Data Types\n\n\nDefinitions of data objects that are good candidates for wider usage:\n\n\nMay Use a Common Money Object\n\n\nUse the following common money structure:\n\n\nMoney:\n  type: object\n  properties:\n    amount:\n      type: number\n      description: Amount expressed as a decimal number of major currency units\n      format: decimal\n      example: 99.95\n    currency:\n      type: string\n      description: 3 letter currency code as defined by ISO-4217\n      format: iso-4217\n      example: EUR\n  required:\n    - amount\n    - currency\n\n\n\n\n\nThe decimal values for \"amount\" describe unit and subunit of the currency in a single value, where\nthe digits before the decimal point are for the major unit and the digits after the decimal point are\nfor the minor unit. Note that some business cases (e.g. transactions in Bitcoin) call for a higher\nprecision, so applications must be prepared to accept values with unlimited precision, unless\nexplicitly stated otherwise in the API specification.\nExamples for correct representations (in EUR):\n\n\n\n\n42.20\n or \n42.2\n = 42 Euros, 20 Cent\n\n\n0.23\n = 23 Cent\n\n\n42.0\n or \n42\n = 42 Euros\n\n\n1024.42\n = 1024 Euros, 42 Cent\n\n\n1024.4225\n = 1024 Euros, 42.25 Cent\n\n\n\n\nMake sure that you don\u2019t convert the \u201camount\u201d field to \nfloat\n / \ndouble\n types when implementing\nthis interface in a specific language or when doing calculations. Otherwise, you might lose\nprecision. Instead, use exact formats like\nJava\u2019s \nBigDecimal\n.\nSee \nStack Overflow\n for more info.\n\n\nSome JSON parsers (NodeJS\u2019s, for example) convert numbers to floats by default. After discussing the\n\npros and cons\n,\nwe\u2019ve decided on \"decimal\" as our amount format. It is not a standard OpenAPI format, but should\nhelp us to avoid parsing numbers as float / doubles.\n\n\nUse common field names and semantics\n\n\nThere exist a variety of field types that are required in multiple places. To achieve consistency across all API implementations, you must use common field names and semantics whenever applicable.\n\n\nGeneric Fields\n\n\nThere are some data fields that come up again and again in API data:\n\n\n\n\n\n\nid\n: the identity of the object. If used, IDs must opaque strings and not numbers. IDs are unique within some documented context, are stable and don't change for a given object once assigned, and are never recycled cross entities.\n\n\n\n\n\n\nxyzId\n: an attribute within one object holding the identifier of another object must use a name that corresponds to the type of the referenced object or the relationship to the referenced object followed by \nId\n (e.g. \ncustomerId\n not \ncustomer_number\n; \nparentNodeId\n for the reference to a parent node from a child node, even if both have the type \nNode\n)\n\n\n\n\n\n\ncreatedDate\n: when the object was created. If used, this must be a \ndate-time\n construct.\n\n\n\n\n\n\nupdateDate\n: when the object was updated. If used, this must be a \ndate-time\n construct.\n\n\n\n\n\n\n_type\n: the kind of thing this object is. If used, the type of this field should be a string. Types allow runtime information on the entity provided that otherwise requires examining the Open API file.\n\n\n\n\n\n\nExample JSON schema:\n\n\ntree_node:\n  type: object\n  properties:\n    id:\n      description: the identifier of this node\n      type: string\n    createdDate:\n      description: when got this node created\n      type: string\n      format: \ndate-time\n\n    editedDate:\n      description: when got this node last updated\n      type: string\n      format: \ndate-time\n\n    \\_type:\n      type: string\n      enum: [ \nLEAF\n, \nNODE\n ]\n    parentNodeId:\n      description: the identifier of the parent node of this node\n      type: string\n  example:\n    id: \n123435\n\n    created: \n2017-04-12T23:20:50.52Z\n\n    modified: \n2017-04-12T23:20:50.52Z\n\n    type: \nLEAF\n\n    parent_node_id: \n534321\n\n\n\n\n\n\nThese properties are not always strictly necessary, but making them idiomatic allows API client developers to build up a common understanding of Zalando's resources. There is very little utility for API consumers in having different names or value types for these fields across APIs.\n\n\nAddress Fields\n\n\nAddress structures play a role in different functional and use-case contexts, including country\nvariances. All attributes that relate to address information should follow the naming\nand semantics defined below.\n\n\naddressee:\n    description:\n      a (natural or legal) person that gets addressed\n    type: object\n    required:\n      - firstName\n      - lastName\n      - street\n      - city\n      - zip\n      - countryCode\n    properties:\n      salutation:\n        description: |\n          a salutation and/or title used for personal contacts to some addressee;\n          not to be confused with the gender information!\n        type: string\n        example: Mr\n      firstName:\n        description: |\n          given name(s) or first name(s) of a person; may also include the middle names.\n        type: string\n        example: Hans Dieter\n      lastName:\n        description: |\n          family name(s) or surname(s) of a person\n        type: string\n        example: Mustermann\n      businessName:\n        description: |\n          company name of the business organization. Used when a business is the actual\n          addressee; for personal shipments to office addresses, use `care_of` instead.\n        type: string\n        example: Consulting Services GmbH\n\naddress:\n    description:\n      an address of a location/destination\n    type: object\n    properties:\n      street:\n        description: |\n          the full street address including house number and street name\n        type: string\n        example: Sch\u00f6nhauser Allee 103\n      additional:\n        description: |\n          further details like building name, suite, apartment number, etc.\n        type: string\n        example: 2. Hinterhof rechts\n      city:\n        description: |\n          name of the city / locality\n        type: string\n        example: Berlin\n      zip:\n        description: |\n          zip code or postal code\n        type: string\n        example: 14265\n      countryCode:\n        description: |\n          the country code according to\n          [iso-3166-1-alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)\n        type: string\n        example: DE\n    required:\n      - street\n      - city\n      - zip\n      - countryCode\n\n\n\n\n\nGrouping and cardinality of fields in specific data types may vary based on the specific use case\n(e.g. combining addressee and address fields into a single type when modeling an address label vs distinct addressee and address types when modeling users and their addresses).\n\n\n{{ book.must }} Follow Hypertext Control Conventions\n\n\nAPIs that provide hypertext controls (links) to interconnect API resources must follow\nthe conventions for naming and modeling of hypertext controls as defined in section \nHypermedia\n.\n\n\n{{ book.must }} Use Problem JSON\n\n\nRFC 7807\n defines the media type \napplication/problem+json\n.\nOperations should return that (together with a suitable status code) when any problem\noccurred during processing and you can give more details than the status code itself\ncan supply, whether it be caused by the client or the server (i.e. both for 4xx or 5xx errors).\n\n\nA previous version of this guideline (before the publication of that RFC and the\nregistration of the media type) told to return \napplication/x.problem+json\n in these\ncases (with the same contents).\nServers for APIs defined before this change should pay attention to the \nAccept\n header sent\nby the client and set the \nContent-Type\n header of the problem response correspondingly.\nClients of such APIs should accept both media types.\n\n\nAPIs may define custom problems types with extension properties, according to their specific needs.\n\n\nThe Open API schema definition can be found \non github\n.\nYou can reference it by using:\n\n\nresponses\n:\n\n  \n503\n:\n\n    \ndescription\n:\n \nService Unavailable\n\n    \nschema\n:\n\n      \n$ref\n:\n \nhttps://zalando.github.io/problem/schema.yaml#/Problem\n\n\n\n\n\n{{ book.must }} Do not expose Stack Traces\n\n\nStack traces contain implementation details that are not part of an API, and on which clients\nshould never rely. Moreover, stack traces can leak sensitive information that partners and third\nparties are not allowed to receive and may disclose insights about vulnerabilities to attackers.\n\n\nData Formats\n\n\n{{ book.must }} Use JSON to Encode Structured Data\n\n\nUse JSON-encoded body payload for transferring structured data.\nThe JSON payload must follow \nRFC-7159\n by having\n(if possible) a serialized object as the top-level structure, since it would allow for future extension.\nThis also applies for collection resources where one naturally would assume an array. See the\n\npagination\n section for an example.\n\n\n{{ book.may }} Use non JSON Media Types for Binary Data or Alternative Content Representations\n\n\nOther media types may be used in following cases:\n* Transferring binary data or data whose structure is not relevant. This is the case if payload structure\nis not interpreted and consumed by clients as is. Example of such use case is downloading images\nin formats JPG, PNG, GIF.\n* In addition to JSON version alternative data representations (e.g. in formats PDF, DOC, XML)\nmay be made available through content negotiation.\n\n\n{{ book.must }} Use Standard Date and Time Formats\n\n\nJSON Payload\n\n\nRead more about date and time format in \nJson Guideline\n.\n\n\nHTTP headers\n\n\nHttp headers including the proprietary headers. Use the \nHTTP date format defined in RFC 7231\n.\n\n\n{{ book.may }} Use Standards for Country, Language and Currency Codes\n\n\nUse the following standard formats for country, language and currency codes:\n\n\n\n\n\n\nISO 3166-1-alpha2 country codes\n\n\n\n\n(It is \u201cGB\u201d, not \u201cUK\u201d, even though \u201cUK\u201d has seen some use at Zalando)\n\n\n\n\n\n\n\n\nISO 639-1 language code\n\n\n\n\nBCP-47\n (based on ISO 639-1) for language variants\n\n\n\n\n\n\n\n\nISO 4217 currency codes\n\n\n\n\n\n\n{{ book.must }} Define Format for Type Number and Integer\n\n\nWhenever an API defines a property of type \nnumber\n or \ninteger\n, the precision must be defined by the format as follows to prevent clients from guessing the precision incorrectly, and thereby changing the value unintentionally:\n\n\n\n\n\n\n\n\ntype\n\n\nformat\n\n\nspecified value range\n\n\n\n\n\n\n\n\n\n\ninteger\n\n\nint32\n\n\ninteger between -2\n31\n and 2\n31\n-1\n\n\n\n\n\n\ninteger\n\n\nint64\n\n\ninteger between -2\n63\n and 2\n63\n-1\n\n\n\n\n\n\ninteger\n\n\nbigint\n\n\narbitrarily large signed integer number\n\n\n\n\n\n\nnumber\n\n\nfloat\n\n\nIEEE 754-2008/ISO 60559:2011 binary64 decimal number\n\n\n\n\n\n\nnumber\n\n\ndouble\n\n\nIEEE 754-2008/ISO 60559:2011 binary128 decimal number\n\n\n\n\n\n\nnumber\n\n\ndecimal\n\n\narbitrarily precise signed decimal number\n\n\n\n\n\n\n\n\nThe precision must be translated by clients and servers into the most specific language types. E.g. for the following definitions the most specific language types in Java will translate to \nBigDecimal\n for \nMoney.amount\n and \nint\n or \nInteger\n for the \nOrderList.page_size\n:\n\n\nMoney\n:\n\n  \ntype\n:\n \nobject\n\n  \nproperties\n:\n\n    \namount\n:\n\n      \ntype\n:\n \nnumber\n\n      \ndescription\n:\n \nAmount expressed as a decimal number of major currency units\n\n      \nformat\n:\n \ndecimal\n\n      \nexample\n:\n \n99.95\n\n  \n \n...\n\n\n\nOrderList\n:\n\n  \ntype\n:\n \nobject\n\n  \nproperties\n:\n\n    \npageSize\n:\n\n      \ntype\n:\n \ninteger\n\n      \ndescription\n:\n \nNumber of orders in list\n\n      \nformat\n:\n \nint32\n\n      \nexample\n:\n \n42\n\n\n\n\n\n{{ book.should }} Prefer standard Media type name \napplication/json\n\n\nPreviously, this guideline allowed the use of custom media types like \napplication/x.zalando.article+json\n.\nThis usage is not recommended anymore and should be avoided, except where it is necessary for cases\nof \nmedia type versioning\n. Instead, the standard media type name \napplication/json\n (or \napplication/problem+json\n for HTTP error details\n) should be used for JSON-formatted data.\n\n\nCustom media types with subtypes beginning with \nx\n bring no advantage compared to the standard media type for JSON, and make automated processing more difficult. They are also \ndiscouraged by RFC 6838\n.", 
            "title": "OpenAPI / Schema"
        }, 
        {
            "location": "/design-principles/schema/#common-data-types", 
            "text": "Definitions of data objects that are good candidates for wider usage:", 
            "title": "Common Data Types"
        }, 
        {
            "location": "/design-principles/schema/#may-use-a-common-money-object", 
            "text": "Use the following common money structure:  Money:\n  type: object\n  properties:\n    amount:\n      type: number\n      description: Amount expressed as a decimal number of major currency units\n      format: decimal\n      example: 99.95\n    currency:\n      type: string\n      description: 3 letter currency code as defined by ISO-4217\n      format: iso-4217\n      example: EUR\n  required:\n    - amount\n    - currency  The decimal values for \"amount\" describe unit and subunit of the currency in a single value, where\nthe digits before the decimal point are for the major unit and the digits after the decimal point are\nfor the minor unit. Note that some business cases (e.g. transactions in Bitcoin) call for a higher\nprecision, so applications must be prepared to accept values with unlimited precision, unless\nexplicitly stated otherwise in the API specification.\nExamples for correct representations (in EUR):   42.20  or  42.2  = 42 Euros, 20 Cent  0.23  = 23 Cent  42.0  or  42  = 42 Euros  1024.42  = 1024 Euros, 42 Cent  1024.4225  = 1024 Euros, 42.25 Cent   Make sure that you don\u2019t convert the \u201camount\u201d field to  float  /  double  types when implementing\nthis interface in a specific language or when doing calculations. Otherwise, you might lose\nprecision. Instead, use exact formats like\nJava\u2019s  BigDecimal .\nSee  Stack Overflow  for more info.  Some JSON parsers (NodeJS\u2019s, for example) convert numbers to floats by default. After discussing the pros and cons ,\nwe\u2019ve decided on \"decimal\" as our amount format. It is not a standard OpenAPI format, but should\nhelp us to avoid parsing numbers as float / doubles.", 
            "title": "May Use a Common Money Object"
        }, 
        {
            "location": "/design-principles/schema/#use-common-field-names-and-semantics", 
            "text": "There exist a variety of field types that are required in multiple places. To achieve consistency across all API implementations, you must use common field names and semantics whenever applicable.", 
            "title": "Use common field names and semantics"
        }, 
        {
            "location": "/design-principles/schema/#generic-fields", 
            "text": "There are some data fields that come up again and again in API data:    id : the identity of the object. If used, IDs must opaque strings and not numbers. IDs are unique within some documented context, are stable and don't change for a given object once assigned, and are never recycled cross entities.    xyzId : an attribute within one object holding the identifier of another object must use a name that corresponds to the type of the referenced object or the relationship to the referenced object followed by  Id  (e.g.  customerId  not  customer_number ;  parentNodeId  for the reference to a parent node from a child node, even if both have the type  Node )    createdDate : when the object was created. If used, this must be a  date-time  construct.    updateDate : when the object was updated. If used, this must be a  date-time  construct.    _type : the kind of thing this object is. If used, the type of this field should be a string. Types allow runtime information on the entity provided that otherwise requires examining the Open API file.    Example JSON schema:  tree_node:\n  type: object\n  properties:\n    id:\n      description: the identifier of this node\n      type: string\n    createdDate:\n      description: when got this node created\n      type: string\n      format:  date-time \n    editedDate:\n      description: when got this node last updated\n      type: string\n      format:  date-time \n    \\_type:\n      type: string\n      enum: [  LEAF ,  NODE  ]\n    parentNodeId:\n      description: the identifier of the parent node of this node\n      type: string\n  example:\n    id:  123435 \n    created:  2017-04-12T23:20:50.52Z \n    modified:  2017-04-12T23:20:50.52Z \n    type:  LEAF \n    parent_node_id:  534321   These properties are not always strictly necessary, but making them idiomatic allows API client developers to build up a common understanding of Zalando's resources. There is very little utility for API consumers in having different names or value types for these fields across APIs.", 
            "title": "Generic Fields"
        }, 
        {
            "location": "/design-principles/schema/#address-fields", 
            "text": "Address structures play a role in different functional and use-case contexts, including country\nvariances. All attributes that relate to address information should follow the naming\nand semantics defined below.  addressee:\n    description:\n      a (natural or legal) person that gets addressed\n    type: object\n    required:\n      - firstName\n      - lastName\n      - street\n      - city\n      - zip\n      - countryCode\n    properties:\n      salutation:\n        description: |\n          a salutation and/or title used for personal contacts to some addressee;\n          not to be confused with the gender information!\n        type: string\n        example: Mr\n      firstName:\n        description: |\n          given name(s) or first name(s) of a person; may also include the middle names.\n        type: string\n        example: Hans Dieter\n      lastName:\n        description: |\n          family name(s) or surname(s) of a person\n        type: string\n        example: Mustermann\n      businessName:\n        description: |\n          company name of the business organization. Used when a business is the actual\n          addressee; for personal shipments to office addresses, use `care_of` instead.\n        type: string\n        example: Consulting Services GmbH\n\naddress:\n    description:\n      an address of a location/destination\n    type: object\n    properties:\n      street:\n        description: |\n          the full street address including house number and street name\n        type: string\n        example: Sch\u00f6nhauser Allee 103\n      additional:\n        description: |\n          further details like building name, suite, apartment number, etc.\n        type: string\n        example: 2. Hinterhof rechts\n      city:\n        description: |\n          name of the city / locality\n        type: string\n        example: Berlin\n      zip:\n        description: |\n          zip code or postal code\n        type: string\n        example: 14265\n      countryCode:\n        description: |\n          the country code according to\n          [iso-3166-1-alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)\n        type: string\n        example: DE\n    required:\n      - street\n      - city\n      - zip\n      - countryCode  Grouping and cardinality of fields in specific data types may vary based on the specific use case\n(e.g. combining addressee and address fields into a single type when modeling an address label vs distinct addressee and address types when modeling users and their addresses).", 
            "title": "Address Fields"
        }, 
        {
            "location": "/design-principles/schema/#bookmust-follow-hypertext-control-conventions", 
            "text": "APIs that provide hypertext controls (links) to interconnect API resources must follow\nthe conventions for naming and modeling of hypertext controls as defined in section  Hypermedia .", 
            "title": "{{ book.must }} Follow Hypertext Control Conventions"
        }, 
        {
            "location": "/design-principles/schema/#bookmust-use-problem-json", 
            "text": "RFC 7807  defines the media type  application/problem+json .\nOperations should return that (together with a suitable status code) when any problem\noccurred during processing and you can give more details than the status code itself\ncan supply, whether it be caused by the client or the server (i.e. both for 4xx or 5xx errors).  A previous version of this guideline (before the publication of that RFC and the\nregistration of the media type) told to return  application/x.problem+json  in these\ncases (with the same contents).\nServers for APIs defined before this change should pay attention to the  Accept  header sent\nby the client and set the  Content-Type  header of the problem response correspondingly.\nClients of such APIs should accept both media types.  APIs may define custom problems types with extension properties, according to their specific needs.  The Open API schema definition can be found  on github .\nYou can reference it by using:  responses : \n   503 : \n     description :   Service Unavailable \n     schema : \n       $ref :   https://zalando.github.io/problem/schema.yaml#/Problem", 
            "title": "{{ book.must }} Use Problem JSON"
        }, 
        {
            "location": "/design-principles/schema/#bookmust-do-not-expose-stack-traces", 
            "text": "Stack traces contain implementation details that are not part of an API, and on which clients\nshould never rely. Moreover, stack traces can leak sensitive information that partners and third\nparties are not allowed to receive and may disclose insights about vulnerabilities to attackers.", 
            "title": "{{ book.must }} Do not expose Stack Traces"
        }, 
        {
            "location": "/design-principles/schema/#data-formats", 
            "text": "", 
            "title": "Data Formats"
        }, 
        {
            "location": "/design-principles/schema/#bookmust-use-json-to-encode-structured-data", 
            "text": "Use JSON-encoded body payload for transferring structured data.\nThe JSON payload must follow  RFC-7159  by having\n(if possible) a serialized object as the top-level structure, since it would allow for future extension.\nThis also applies for collection resources where one naturally would assume an array. See the pagination  section for an example.", 
            "title": "{{ book.must }} Use JSON to Encode Structured Data"
        }, 
        {
            "location": "/design-principles/schema/#bookmay-use-non-json-media-types-for-binary-data-or-alternative-content-representations", 
            "text": "Other media types may be used in following cases:\n* Transferring binary data or data whose structure is not relevant. This is the case if payload structure\nis not interpreted and consumed by clients as is. Example of such use case is downloading images\nin formats JPG, PNG, GIF.\n* In addition to JSON version alternative data representations (e.g. in formats PDF, DOC, XML)\nmay be made available through content negotiation.", 
            "title": "{{ book.may }} Use non JSON Media Types for Binary Data or Alternative Content Representations"
        }, 
        {
            "location": "/design-principles/schema/#bookmust-use-standard-date-and-time-formats", 
            "text": "", 
            "title": "{{ book.must }} Use Standard Date and Time Formats"
        }, 
        {
            "location": "/design-principles/schema/#json-payload", 
            "text": "Read more about date and time format in  Json Guideline .", 
            "title": "JSON Payload"
        }, 
        {
            "location": "/design-principles/schema/#http-headers", 
            "text": "Http headers including the proprietary headers. Use the  HTTP date format defined in RFC 7231 .", 
            "title": "HTTP headers"
        }, 
        {
            "location": "/design-principles/schema/#bookmay-use-standards-for-country-language-and-currency-codes", 
            "text": "Use the following standard formats for country, language and currency codes:    ISO 3166-1-alpha2 country codes   (It is \u201cGB\u201d, not \u201cUK\u201d, even though \u201cUK\u201d has seen some use at Zalando)     ISO 639-1 language code   BCP-47  (based on ISO 639-1) for language variants     ISO 4217 currency codes", 
            "title": "{{ book.may }} Use Standards for Country, Language and Currency Codes"
        }, 
        {
            "location": "/design-principles/schema/#bookmust-define-format-for-type-number-and-integer", 
            "text": "Whenever an API defines a property of type  number  or  integer , the precision must be defined by the format as follows to prevent clients from guessing the precision incorrectly, and thereby changing the value unintentionally:     type  format  specified value range      integer  int32  integer between -2 31  and 2 31 -1    integer  int64  integer between -2 63  and 2 63 -1    integer  bigint  arbitrarily large signed integer number    number  float  IEEE 754-2008/ISO 60559:2011 binary64 decimal number    number  double  IEEE 754-2008/ISO 60559:2011 binary128 decimal number    number  decimal  arbitrarily precise signed decimal number     The precision must be translated by clients and servers into the most specific language types. E.g. for the following definitions the most specific language types in Java will translate to  BigDecimal  for  Money.amount  and  int  or  Integer  for the  OrderList.page_size :  Money : \n   type :   object \n   properties : \n     amount : \n       type :   number \n       description :   Amount expressed as a decimal number of major currency units \n       format :   decimal \n       example :   99.95 \n     ...  OrderList : \n   type :   object \n   properties : \n     pageSize : \n       type :   integer \n       description :   Number of orders in list \n       format :   int32 \n       example :   42", 
            "title": "{{ book.must }} Define Format for Type Number and Integer"
        }, 
        {
            "location": "/design-principles/schema/#bookshould-prefer-standard-media-type-name-applicationjson", 
            "text": "Previously, this guideline allowed the use of custom media types like  application/x.zalando.article+json .\nThis usage is not recommended anymore and should be avoided, except where it is necessary for cases\nof  media type versioning . Instead, the standard media type name  application/json  (or  application/problem+json  for HTTP error details ) should be used for JSON-formatted data.  Custom media types with subtypes beginning with  x  bring no advantage compared to the standard media type for JSON, and make automated processing more difficult. They are also  discouraged by RFC 6838 .", 
            "title": "{{ book.should }} Prefer standard Media type name application/json"
        }, 
        {
            "location": "/api-docs-template/", 
            "text": "This can be used as a template to start a good intro to a products API docs\n\n\nhttps://bradfults.com/the-best-api-documentation-b9e46400379a\n\n\nrefs and examples\n\n\nhttps://developer.fleetio.com/docs/errors\n\n\nAn Introduction to REST\n\n\nBackground\n\n\nWhen we talk about our API, we use terms like \u201cREST\u201d and \u201cRESTful.\u201d \u201cREST\u201d stands for Representational State Transfer. It\u2019s an architectural style that\u2019s an alternative to RPC or SOAP-based web services.\n\n\nWhile there\u2019s no official REST standard, there are common approaches and best practices used across the engineering community that help define how RESTful APIs should work. For example, most RESTful APIs follow six specific constraints or design rules.\n\n\nThe API is organized around REST. The API has predictable, resource-oriented URLs, and uses HTTP response codes to indicate API errors. We use built-in HTTP features, like HTTP authentication and HTTP verbs, which are understood by off-the-shelf HTTP clients. We support cross-origin resource sharing, allowing you to interact securely with our API from a client-side web application (though you should never expose your secret API key in any public website's client-side code). JSON is returned by all API responses, including errors.\nTo make an API as explorable as possible, users can have test mode and live mode API keys. There is no \"switch\" for changing between modes, just use the appropriate key to perform a live or test transaction. Requests made with test mode credentials never hit production\n\n\nAn operation is a unit of a REST API that you can call. An operation comprises an HTTP verb and a URL path that is subordinate to the context root of the API. By configuring the operation, you define how the API is exposed to your developers.\n\n\nAuthentication\n\n\nTODO\n\n\nSchema\n\n\nHTTP Methods and Verbs\n\n\nYou may see these standard HTTP methods referred to as CRUD, or Create, Read, Update, Delete. Although CRUD has roots in database operations, you can also map those operations to the standard HTTP methods. For example, use a POST request to create a new resource, a GET request to read or retrieve a resource, a PATCH request to edit a resource, and a DELETE request to delete a resource.\n\n\nThe URLs are expected to following normal REST conventions.\n\n\n\n\n\n\n\n\nHTTP Method\n\n\nCtrl Action\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\nGET\n\n\nindex\n\n\nRead a resource or list of resources\n\n\n\n\n\n\nPOST\n\n\nsave\n\n\nCreate a new resource (when the key is not known a-priori) See note.\n\n\n\n\n\n\nPUT\n\n\nupdate\n\n\nFully replaces an existing resource or create one if the id key is pre-defined\n\n\n\n\n\n\nPatch\n\n\nupdate\n\n\nUpdate an existing resource or create one if the key is pre-defined\n\n\n\n\n\n\nDELETE\n\n\nRemove\n\n\nRemove a resource\n\n\n\n\n\n\n\n\nENDPOINTS AND ACTIONS\n\n\n\n\n\n\n\n\nEndpoint\n\n\nAction\n\n\nHTTP Verbs\n\n\nReturns\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n/thing\n\n\nlist(params)\n\n\nGET\n\n\nArray - a paginated array of things\n\n\n200\n\n\n\n\n\n\n/thing/123\n\n\nshow(id)\n\n\nGET\n\n\nObject - \n  one thing where id=123\n\n\n200\n\n\n\n\n\n\n/thing\n\n\ninsert(body)\n\n\nPOST\n\n\nObject - \n Inserts a new thing and returns it\n\n\n201\n\n\n\n\n\n\n/thing/123\n\n\nupdate(id, body)\n\n\nPUT\n\n\nObject - \n  update and return the thing where id=123\n\n\n200\n\n\n\n\n\n\n/thing/123\n\n\ndelete(id)\n\n\nDELETE\n\n\nnothing \n  Deletes the thing where id=123\n\n\n204\n\n\n\n\n\n\n\n\n\n\nPATCH\n\n\nTODO\n\n\n200\n\n\n\n\n\n\n\n\nIdempotent Requests\n\n\nThe API supports \nidempotency\n for safely retrying requests without accidentally performing the same operation twice. For example, if a request to create a doodad fails due to a network connection error, you can retry the request with the same idempotency key to guarantee that only a single charge is created.\nGET and DELETE requests are idempotent by definition, meaning that the same backend work will occur no matter how many times the same request is issued. You shouldn't send an idempotency key with these verbs because it will have no effect.\nTo perform an idempotent request, provide an additional \nIdempotency-Key: \nkey\n header to the request.\n\n\nresponses\n\n\nSuccess Status Codes\n\n\n\n\n\n\n\n\nStatus Code\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n200 - OK\n\n\nEverything worked as expected. default\n\n\n\n\n\n\n201 - CREATED\n\n\nResource/instance was created. returned from \nsave\n action\n\n\n\n\n\n\n204 - NO_CONTENT\n\n\nresponse code on successful DELETE request\n\n\n\n\n\n\n404 - NOT_FOUND\n\n\nThe requested resource doesn't exist.\n\n\n\n\n\n\n422\n\n\nValidation errors.\n\n\n\n\n\n\n405 - METHOD_NOT_ALLOWED\n\n\nIf method (GET,POST,etc..) is not setup in \nstatic allowedMethods\n for action or resource is read only\n\n\n\n\n\n\n406 - NOT_ACCEPTABLE\n\n\nAccept header requests a response in an unsupported format. not configed in mime-types. RestResponder uses this\n\n\n\n\n\n\n\n\nResponse Body.\n\n\nAny response body will be one of the following:\n\n\n\n\nA representation of a resource\n\n\nAn array of representations of a resource (either a JSON array, or list representation in xml)\n\n\nan empty body\n\n\n\n\nAny 'envelope' information is conveyed in headers.\n\n\nPagination\n\n\nBecause large data sets are possible, paging is used for all GET index actions.\nThe default page size is set to 100. 9ci will return four response headers along with the result set.\n\n\n\n\n\n\n\n\nHeader\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nX-Pagination-Limit\n\n\nThe per page size limit. Defaults to 100\n\n\n\n\n\n\nX-Pagination-Current-Page\n\n\nThe current page. Defaults to 1.\n\n\n\n\n\n\nX-Pagination-Total-Pages\n\n\nThe total number of pages in the result list.\n\n\n\n\n\n\nX-Pagination-Total-Count\n\n\nThe total number of items across all pages.\n\n\n\n\n\n\n\n\nTo retrieve data for a specific page, simply specify the page query parameter \n/doodad?page=5\n.\n\n\n\n\n\n\n\n\nQuery parameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npage\n\n\nThe page number to show\n\n\n\n\n\n\nlimit or max\n\n\nThe number of items in the result list to show per page\n\n\n\n\n\n\noffset\n\n\nThe item number to start from (zero based) in the result list. Don't use both this and page\n\n\n\n\n\n\n\n\nPages start at 1 of course. Any value less than 1 will default to the first page while any value greater than Pagination-Total-Pages will simply return an empty result set.\n\n\nErrors\n\n\nErrors come in the form of HTTP response codes to indicate the success or failure of an API request. as listed as well as validation errors\n\n\nNot all errors map cleanly onto HTTP response codes, however. When a request is valid but does not complete successfully (e.g., a card is declined), we return a 422 error code.\n\n\n\n\n\n\n\n\nStatus Code\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n422 - UNPROCESSABLE_ENTITY\n\n\nValidation errors.\n\n\n\n\n\n\n404 - NOT_FOUND\n\n\nThe requested resource doesn't exist.\n\n\n\n\n\n\n405 - METHOD_NOT_ALLOWED\n\n\nIf method (GET,POST,etc..) is not setup in \nstatic allowedMethods\n for action or resource is read only\n\n\n\n\n\n\n406 - NOT_ACCEPTABLE\n\n\nAccept header requests a response in an unsupported format. not configed in mime-types. RestResponder uses this\n\n\n\n\n\n\n\n\nValidation Errors 422\n\n\nIf you try to create or update a record with invalid data, you'll receive a 422 response code and the operation will fail.\n\n\nYou'll also receive an errors object in the response body with the resulting error messages. This object will have one key for each field with errors.\n\n\nEach field will have an array of human readable error messages, as show below:\n\nTODO", 
            "title": "Sample API Docs"
        }, 
        {
            "location": "/api-docs-template/#refs-and-examples", 
            "text": "https://developer.fleetio.com/docs/errors", 
            "title": "refs and examples"
        }, 
        {
            "location": "/api-docs-template/#an-introduction-to-rest", 
            "text": "Background  When we talk about our API, we use terms like \u201cREST\u201d and \u201cRESTful.\u201d \u201cREST\u201d stands for Representational State Transfer. It\u2019s an architectural style that\u2019s an alternative to RPC or SOAP-based web services.  While there\u2019s no official REST standard, there are common approaches and best practices used across the engineering community that help define how RESTful APIs should work. For example, most RESTful APIs follow six specific constraints or design rules.  The API is organized around REST. The API has predictable, resource-oriented URLs, and uses HTTP response codes to indicate API errors. We use built-in HTTP features, like HTTP authentication and HTTP verbs, which are understood by off-the-shelf HTTP clients. We support cross-origin resource sharing, allowing you to interact securely with our API from a client-side web application (though you should never expose your secret API key in any public website's client-side code). JSON is returned by all API responses, including errors.\nTo make an API as explorable as possible, users can have test mode and live mode API keys. There is no \"switch\" for changing between modes, just use the appropriate key to perform a live or test transaction. Requests made with test mode credentials never hit production  An operation is a unit of a REST API that you can call. An operation comprises an HTTP verb and a URL path that is subordinate to the context root of the API. By configuring the operation, you define how the API is exposed to your developers.", 
            "title": "An Introduction to REST"
        }, 
        {
            "location": "/api-docs-template/#authentication", 
            "text": "TODO", 
            "title": "Authentication"
        }, 
        {
            "location": "/api-docs-template/#schema", 
            "text": "", 
            "title": "Schema"
        }, 
        {
            "location": "/api-docs-template/#http-methods-and-verbs", 
            "text": "You may see these standard HTTP methods referred to as CRUD, or Create, Read, Update, Delete. Although CRUD has roots in database operations, you can also map those operations to the standard HTTP methods. For example, use a POST request to create a new resource, a GET request to read or retrieve a resource, a PATCH request to edit a resource, and a DELETE request to delete a resource.  The URLs are expected to following normal REST conventions.     HTTP Method  Ctrl Action  Purpose      GET  index  Read a resource or list of resources    POST  save  Create a new resource (when the key is not known a-priori) See note.    PUT  update  Fully replaces an existing resource or create one if the id key is pre-defined    Patch  update  Update an existing resource or create one if the key is pre-defined    DELETE  Remove  Remove a resource", 
            "title": "HTTP Methods and Verbs"
        }, 
        {
            "location": "/api-docs-template/#endpoints-and-actions", 
            "text": "Endpoint  Action  HTTP Verbs  Returns  code      /thing  list(params)  GET  Array - a paginated array of things  200    /thing/123  show(id)  GET  Object -    one thing where id=123  200    /thing  insert(body)  POST  Object -   Inserts a new thing and returns it  201    /thing/123  update(id, body)  PUT  Object -    update and return the thing where id=123  200    /thing/123  delete(id)  DELETE  nothing    Deletes the thing where id=123  204      PATCH  TODO  200", 
            "title": "ENDPOINTS AND ACTIONS"
        }, 
        {
            "location": "/api-docs-template/#idempotent-requests", 
            "text": "The API supports  idempotency  for safely retrying requests without accidentally performing the same operation twice. For example, if a request to create a doodad fails due to a network connection error, you can retry the request with the same idempotency key to guarantee that only a single charge is created.\nGET and DELETE requests are idempotent by definition, meaning that the same backend work will occur no matter how many times the same request is issued. You shouldn't send an idempotency key with these verbs because it will have no effect.\nTo perform an idempotent request, provide an additional  Idempotency-Key:  key  header to the request.", 
            "title": "Idempotent Requests"
        }, 
        {
            "location": "/api-docs-template/#responses", 
            "text": "", 
            "title": "responses"
        }, 
        {
            "location": "/api-docs-template/#success-status-codes", 
            "text": "Status Code  Description      200 - OK  Everything worked as expected. default    201 - CREATED  Resource/instance was created. returned from  save  action    204 - NO_CONTENT  response code on successful DELETE request    404 - NOT_FOUND  The requested resource doesn't exist.    422  Validation errors.    405 - METHOD_NOT_ALLOWED  If method (GET,POST,etc..) is not setup in  static allowedMethods  for action or resource is read only    406 - NOT_ACCEPTABLE  Accept header requests a response in an unsupported format. not configed in mime-types. RestResponder uses this", 
            "title": "Success Status Codes"
        }, 
        {
            "location": "/api-docs-template/#response-body", 
            "text": "Any response body will be one of the following:   A representation of a resource  An array of representations of a resource (either a JSON array, or list representation in xml)  an empty body   Any 'envelope' information is conveyed in headers.", 
            "title": "Response Body."
        }, 
        {
            "location": "/api-docs-template/#pagination", 
            "text": "Because large data sets are possible, paging is used for all GET index actions.\nThe default page size is set to 100. 9ci will return four response headers along with the result set.     Header  Description      X-Pagination-Limit  The per page size limit. Defaults to 100    X-Pagination-Current-Page  The current page. Defaults to 1.    X-Pagination-Total-Pages  The total number of pages in the result list.    X-Pagination-Total-Count  The total number of items across all pages.     To retrieve data for a specific page, simply specify the page query parameter  /doodad?page=5 .     Query parameters  Description      page  The page number to show    limit or max  The number of items in the result list to show per page    offset  The item number to start from (zero based) in the result list. Don't use both this and page     Pages start at 1 of course. Any value less than 1 will default to the first page while any value greater than Pagination-Total-Pages will simply return an empty result set.", 
            "title": "Pagination"
        }, 
        {
            "location": "/api-docs-template/#errors", 
            "text": "Errors come in the form of HTTP response codes to indicate the success or failure of an API request. as listed as well as validation errors  Not all errors map cleanly onto HTTP response codes, however. When a request is valid but does not complete successfully (e.g., a card is declined), we return a 422 error code.     Status Code  Description      422 - UNPROCESSABLE_ENTITY  Validation errors.    404 - NOT_FOUND  The requested resource doesn't exist.    405 - METHOD_NOT_ALLOWED  If method (GET,POST,etc..) is not setup in  static allowedMethods  for action or resource is read only    406 - NOT_ACCEPTABLE  Accept header requests a response in an unsupported format. not configed in mime-types. RestResponder uses this", 
            "title": "Errors"
        }, 
        {
            "location": "/api-docs-template/#validation-errors-422", 
            "text": "If you try to create or update a record with invalid data, you'll receive a 422 response code and the operation will fail.  You'll also receive an errors object in the response body with the resulting error messages. This object will have one key for each field with errors.  Each field will have an array of human readable error messages, as show below: TODO", 
            "title": "Validation Errors 422"
        }, 
        {
            "location": "/tutorial/stock/", 
            "text": "Getting started\n\n\nFor this tutorial you will need\n\n\n\n\n\n\nJDK (I advise 8, but you can take 7 as well).\n\n\n\n\n\n\nGit.\n\n\n\n\n\n\nGrails 3.2.11 (you can install it with \nhttp://sdkman.io\n on most Unix based systems.)\n\n\n\n\n\n\nAfter all is installed clone the repo:\n\n\ngit clone https://github.com/9ci/angle-grinder\n\n\n\n\nand switch to branch \nrest_tutorial\n branch, and go to \nangle-grinder/grails/restTutorial\n, the final result is in\nthe \nsnapshot\n folder for each step\n\n\nSo first let's create new grails app:\n\n\n$ grails create-app -profile rest-api -features hibernate4 resttutorail\nApplication created at angle-grinder/grails/restTutorial\n\n\n\n\nGrails 3 provides several different profiles you can read about them in the \ngrails docs\n\n\nCreating an API with Grails Web Services\n\n\nAs described in the \ngrails ws docs\n\nwe will use the default out of the box functionality as a starting point.\n\n\nCreating a GORM domain\n\n\ngrails create-domain-class Contact\n\n\n\n\nThen set it up like so:\n\n\nContact.groovy\n\n\npackage\n \nresttutorial\n\n\n\nclass\n \nContact\n \n{\n\n  \nString\n \nfirstName\n\n  \nString\n \nlastName\n\n  \nString\n \nemail\n\n  \nBoolean\n \ninactive\n\n\n  \nstatic\n \nconstraints\n \n=\n \n{\n\n    \nfirstName\n \nnullable:\n \nfalse\n\n    \ninactive\n \nbindable:\n \nfalse\n\n  \n}\n\n\n}\n\n\n\n\nTo avoid writing \nnullable: true\n we will set the default to allow nulls for fields\nAdd the following to \ngrails-app/conf/application.groovy\n\n\napplication.groovy\n\n\ngrails\n.\ngorm\n.\ndefault\n.\nconstraints\n \n=\n \n{\n\n  \n*\n \n(\nnullable:\n \ntrue\n,\n \nblank:\n \ntrue\n)\n\n\n}\n\n\n\n\nWe will load 100 rows of mock test data from a file \nContacts.json\n in resources.\nThe mock data was generated from a great tool \nhttps://www.mockaroo.com\n\n\nAdd the following code to \ngrails-app/init/BootStrap.groovy\n\n\nBootStrap.groovy\n\n\npackage\n \nresttutorial\n\n\n\nimport\n \ngroovy.json.JsonSlurper\n\n\n\nclass\n \nBootStrap\n \n{\n\n    \ndef\n \ngrailsApplication\n\n    \ndef\n \ninit\n \n=\n \n{\n \nservletContext\n \n-\n\n        \ndef\n \ndata\n \n=\n \nnew\n \nJsonSlurper\n().\nparse\n(\nnew\n \nFile\n(\n../resources/Contacts.json\n))\n\n        \ndata\n.\neach\n{\n\n          \nContact\n \ncontact\n \n=\n \nnew\n \nContact\n(\nit\n)\n\n          \ncontact\n.\nsave\n(\nfailOnError:\ntrue\n,\nflush:\n \ntrue\n)\n\n        \n}\n\n    \n}\n\n    \ndef\n \ndestroy\n \n=\n \n{\n\n    \n}\n\n\n}\n\n\n\n\nAdding the \n@Resource\n annotation to our domain\n\n\n:url-dr: {docs-grails}#domainResources\n\n\nSo now we can start working on creating REST Api for our app.\nThe easiest way is to use {url-dr}[domain resources].\nSo as we see from {url-dr}[docs] we just need to update our domain a bit (just add {docs-grails-api}/grails/rest/Resource.html[@Resource] anotation) in such a way:\n\n\nContact.groovy\n\n\nimport\n \ngrails.rest.Resource\n\n\n\n@Resource\n(\nuri\n \n=\n \n/contact\n,\n \nformats\n \n=\n \n[\njson\n])\n\n\nclass\n \nContact\n \n{\n\n  \n...\n\n\n}\n\n\n\n\n\n\n:memo \nOn plural resource names\n\nAs you will notice we did not pluralize it to contacts above as many will do.\nWe are aware of the debate on this in the rest world. We feel this will cause confusion down the line to do it.\n\n\n\n\nEnglish plural rules like \"cherry/cherries\" or \"goose/geese/moose/meese\" are not the nicest thing to think of while developing API, particularly when english is not your mother tongue.\n\n\nMany times, as in Grails, we want to generate endpoint from the model, which is usually singular. It does not play nicely with the above pluralization exceptions and creates more work maintaining UrlMappings.\n\n\nWhen the model is singular, which is normally is for us, keeping the rest endpoint singular will have the rest developers and the grails developers speaking the same language\n\n\nThe argument \"usually you start querying by a Get to display a list\" does not refer to any real use case. And we will end up querying single items as much as and even more than a list of items.\n\n\n\n\n\n\nThe \nRestfullController\n\n\n@Resource\n creates a RestfullController for the domain\n\n\n\n\n \nThe \n@Resource\n annotation\n\nis used in an ASTTransformation that creates a controller that extends RestfullController. See \nResourceTransform\n for details on how it does this. Later we will show how to specify the controller to user with superClass property.\n\n\n\n\nDefault Endpoints and Status Codes\n\n\nUrl Mappings\n\n\nThe \nExtending Restful Controllers\n section of the \ngrails docs\n outlines the action names and the URIs they map to:\n\n\n.URI, Controller Action and Response Defaults\n[cols=\"2,1,1,3\", format=\"csv\", options=\"header\", width=\"80\",grid=rows]\n|===\nURI, Method, Action, Response Data\n/contact , GET , index , Paged List\n/contact/create, GET , create , Contact.newInstance() unsaved\n/contact, POST , save , The successfully saved contact (same as show's get)\n/contact/\n\\({id}, GET , show , The contact for the id\n/contact/\\)\n/edit, GET , edit , The contact for the id. same as show\n/contact/\n\\({id}, PUT , update , The successfully updated contact\n/contact/\\)\n, DELETE , delete , Empty response with HTTP status code 204\n|===\n\n\n==== Status Code Defaults\n\n\nPiecing together the {docs-HttpStatus}[HttpStatus codes] and results from RestfullController, RestResponder and _errors.gson,\nthese are what looks like the out of the box status codes as of Grails 3.2.2\n\n\n.Status Codes Out Of Box\n[options=\"header\", cols=\"1,2\", grid=rows]\n|===\n| Status Code               | Description\n| 200 - OK                  | Everything worked as expected. default\n| 201 - CREATED             | Resource/instance was created. returned from \nsave\n action\n| 204 - NO_CONTENT          | response code on successful DELETE request\n| 404 - NOT_FOUND           | The requested resource doesn't exist.\n| 405 - METHOD_NOT_ALLOWED  | If method (GET,POST,etc..) is not setup in \nstatic allowedMethods\n for action or resource is read only\n| 406 - NOT_ACCEPTABLE      | Accept header requests a response in an unsupported format. not configed in mime-types. RestResponder uses this\n| 422 - UNPROCESSABLE_ENTITY | Validation errors.\n|===\n\n\n=== API Namespace\n\n\nA Namespace is a mechanism to partition resources into a logically named group.\n\n\nSo the controllers that response for the REST endpoints we will move to separate namespace to avoid cases when we need to\nhave Controllers for GSP rendering or some other not related to REST stuff.\n\n\nAs a our preferred namespace design we will use the \"api\" namespace prefix for the rest of the tutorial.\nSo we will add \nnamespace = 'api'\n on the contact @Resource. @Resource has also property \nuri\n but it will override namespace property,\nfor example if @Resource(namespace = 'api', uri='contacts', formats = [\"json\"]) url for resource will be \nlocalhost:8080/contacts\n, not\n\n\n.Contact.groovy\n\n@Resource\n(\nnamespace\n \n=\n \napi\n,\n \nformats\n \n=\n \n[\njson\n])\n\n\nclass\n \nContact\n\n\n\n\nAlso we need to update UrlMappings.groovy, there are two ways:\n\n\n\n\nAdd \n/api\n prefix to each mapping for example  \nget \n/api/$controller(.$format)?\n(action:\nindex\n)\n\n\nUse \ngroup\n property\n\n\n\n\nWe will use the second case:\n\n\n.UrlMappings.groovy\n\npackage\n \nresttutorial\n\n\n\nclass\n \nUrlMappings\n \n{\n\n\n    \nstatic\n \nmappings\n \n=\n \n{\n\n      \ngroup\n(\n/api\n)\n \n{\n\n        \ndelete\n \n/$controller/$id(.$format)?\n(\naction:\ndelete\n)\n\n        \nget\n \n/$controller(.$format)?\n(\naction:\nindex\n)\n\n        \nget\n \n/$controller/$id(.$format)?\n(\naction:\nshow\n)\n\n        \npost\n \n/$controller(.$format)?\n(\naction:\nsave\n)\n\n        \nput\n \n/$controller/$id(.$format)?\n(\naction:\nupdate\n)\n\n        \npatch\n \n/$controller/$id(.$format)?\n(\naction:\npatch\n)\n\n      \n}\n\n        \n...\n\n    \n}\n\n\n}\n\n\n\n\nYou can see all available endpoints that Grails create for us with url-mappings-report:\n\n\n\n\n$ grails url-mappings-report\n[options=\"header\", cols=\"1,2\", grid=rows]\nDynamic Mappings\n |    *     | ERROR: 500                                | View:   /error           |\n |    *     | ERROR: 404                                | View:   /notFound        |\n |   GET    | /api/\n\\({controller}(.\\)\n{format)?            | Action: index            |\n |   POST   | /api/\n\\({controller}(.\\)\n{format)?            | Action: save             |\n |  DELETE  | /api/\n\\({controller}/\\)\n(.\n\\({format)?      | Action: delete           |\n |   GET    | /api/\\)\n/\n\\({id}(.\\)\n{format)?      | Action: show             |\n |   PUT    | /api/\n\\({controller}/\\)\n(.\n\\({format)?      | Action: update           |\n |  PATCH   | /api/\\)\n/\n\\({id}(.\\)\n{format)?      | Action: patch            |\n\n\nController: application\n |    *     | /                                                  | Action: index            |\n\n\nController: contact\n |   GET    | /api/contact/create                                | Action: create           |\n |   GET    | /api/contact/\n\\({id}/edit                            | Action: edit             |\n |   POST   | /api/contact                                       | Action: save             |\n |   GET    | /api/contact                                       | Action: index            |\n |  DELETE  | /api/contact/\\)\n                                 | Action: delete           |\n |  PATCH   | /api/contact/\n\\({id}                                 | Action: patch            |\n |   PUT    | /api/contact/\\)\n                                 | Action: update           |\n |   GET    | /api/contact/${id}                                 | Action: show             |\n\n\n\n\n=== Using CURL to test CRUD and List\n\n\nFire up the app with \nrun-app\n\n\n===== GET (list):\n\n\ncurl -i -X GET -H \"Content-Type: application/json\"  localhost:8080/api/contact\nHTTP/1.1 200\nX-Application-Context: application:development\nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:30:31 GMT\n\n\n[{\"id\":1,\"email\":\"\n\",\"firstName\":\"Marie\",\"lastName\":\"Scott\"},{\"id\":2,\"email\":\"\n\",\"firstName\":\"Joseph\",\"lastName\":\"Rodriguez\"}, ...\n\n\n===== POST:\n\n\ncurl -i -X POST -H \"Content-Type: application/json\" -d '{\"firstName\":\"Joe\", \"lastName\": \"Cool\"}' localhost:8080/api/contact\nHTTP/1.1 201\nX-Application-Context: application:development\nLocation: \nhttp://localhost:8080/api/contact/101\n\nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:30:44 GMT\n\n\n{\"id\":101,\"firstName\":\"Joe\",\"lastName\":\"Cool\"}\n\n\n===== GET (by id):\n\n\ncurl -i -X GET -H \"Content-Type: application/json\"  localhost:8080/api/contact/101\nHTTP/1.1 200\nX-Application-Context: application:development\nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:31:00 GMT\n\n\n{\"id\":101,\"firstName\":\"Joe\",\"lastName\":\"Cool\"}\n\n\n===== PUT:\n\n\ncurl -i -X PUT -H \"Content-Type: application/json\" -d '{\"firstName\": \"New Name\", \"lastName\": \"New Last name\"}' localhost:8080/api/contact/101\nHTTP/1.1 200\nX-Application-Context: application:development\nLocation: \nhttp://localhost:8080/api/contact/101\n\nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:32:01 GMT\n\n\n{\"id\":101,\"firstName\":\"New Name\",\"lastName\":\"New Last name\"}\n\n\n===== DELETE:\n\n\ncurl -i -X DELETE -H \"Content-Type: application/json\"  localhost:8080/api/contact/50\nHTTP/1.1 204\nX-Application-Context: application:development\nDate: Mon, 31 Jul 2017 12:32:24 GMT\n\n\n\n\n===== 422 - Post Validation Error:\n\n\ncurl -i -X POST -H \"Content-Type: application/json\" -d '{\"lastName\": \"Cool\"}' localhost:8080/api/contact\nHTTP/1.1 422\nX-Application-Context: application:development\nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:32:41 GMT\n\n\n{\"message\":\"Property [firstName] of class [class resttutorial.Contact] cannot be null\",\"path\":\"/contact/index\",\"_links\":{\"self\":{\"href\":\"\nhttp://localhost:8080/contact/index\n\"}}}\n\n\n===== 404 - Get Error:\n\n\ncurl -i -X GET -H \"Content-Type: application/json\"  localhost:8080/api/contact/105\nHTTP/1.1 404\nX-Application-Context: application:development\nContent-Type: application/json;charset=UTF-8\nContent-Language: en-US\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:32:55 GMT\n\n\n{\"message\":\"Not Found\",\"error\":404}\n\n\n===== 406 - NOT_ACCEPTABLE:\n\n\nWe did not setup XML support so we will get a 406. You may try adding XML to formats to see if this.\n\n\ncurl -i -X GET -H \"Accept: application/xml\"  \nhttp://localhost:8080/api/contact/8\n\nHTTP/1.1 406\nX-Application-Context: application:development\nContent-Length: 0\nDate: Mon, 31 Jul 2017 12:33:13 GMT\n\n\n\n\n=== Functional Tests for the API\n\n\nThe next step is to add functional tests for our app. One option is to use Grails functional tests and RestBuilder.\nWe will cover another javscript option later the angle-grinder section\nThe line in the buidl.gradle that allows us to use RestBuilder is\n\n\n\n\ntestCompile \"org.grails:grails-datastore-rest-client\"\n\n\nit is added by default when you create a grails app with \n-profile rest-api\n\n\n==== POST testing example\n\n\nHere is an example of \nPOST\n request (creating of a new contact).\nRestBuilder we use to emulate request from external source. Note, in Grails3 integration tests run on the random port,\nso you cant call \nhttp://localhost:8080/api/contact\n , but we can use \nserverPort\n variable instead. And to make it more\nintelligent lets use baseUrl. See example:\n\n\n.ContactSpec.groovy\n\npackage\n \nresttutorial\n\n\n\nimport\n \ngrails.plugins.rest.client.RestBuilder\n\n\nimport\n \ngrails.plugins.rest.client.RestResponse\n\n\nimport\n \ngrails.test.mixin.integration.Integration\n\n\nimport\n \norg.grails.web.json.JSONElement\n\n\nimport\n \nspock.lang.Shared\n\n\nimport\n \nspock.lang.Specification\n\n\n\n@Integration\n\n\nclass\n \nContactSpec\n \nextends\n \nSpecification\n \n{\n\n\n    \n@Shared\n\n    \nRestBuilder\n \nrest\n \n=\n \nnew\n \nRestBuilder\n()\n\n\n    \ndef\n \ngetBaseUrl\n(){\nhttp://localhost:${serverPort}/api\n}\n\n\n    \nvoid\n \ncheck POST request\n()\n \n{\n\n        \nwhen:\n\n        \nRestResponse\n \nresponse\n \n=\n \nrest\n.\npost\n(\n${baseUrl}/contact\n){\n\n          \njson\n([\n\n            \nfirstName:\n \nTest contact\n,\n\n            \nemail:\nfoo@bar.com\n,\n\n            \ninactive:\ntrue\n \n//is bindable: false - see domain, so it wont be set to contact\n\n          \n])\n\n        \n}\n\n\n        \nthen:\n\n        \nresponse\n.\nstatus\n \n==\n \n201\n\n        \nJSONElement\n \njson\n \n=\n \nresponse\n.\njson\n\n        \njson\n.\nid\n \n==\n \n101\n\n        \njson\n.\nfirstName\n \n==\n \nTest contact\n\n        \njson\n.\nlastName\n \n==\n \nnull\n\n        \njson\n.\nemail\n \n==\n \nfoo@bar.com\n\n        \njson\n.\ninactive\n \n==\n \nnull\n\n    \n}\n\n\n}\n\n\n\n\nMore tests examples are in the snapshot1 project's\n{url-snapshot1}/src/integration-test/groovy/resttutorial/ContactSpec.groovy[ContactSpec.groovy]\n\n\n=== GSON and Grails Views Defaults\n\n\nAs you can see by inspecting the views directory, by default Grails creates a number of gson files. Support for them is\nprovided with \nhttp://views.grails.org/latest/#_introduction[Grails\n Views Plugin]\n\n\nThe obvious question how does it work. If you look at sources of the RestfullController it doesn't \"call\" this templates\nexplicitly. So under the hood plugin just looks on request, if url ends on \n.json\n(localhost:8080/api/contact/1.json) or if\n\nAccept\n header containing \napplication/json\n the .gson view will be rendered.\n\n\nIf you delete default generated templates, then it will show default Grails page. Go ahead and try to delete \nnotFound.gson\n\nand try\n\n\n\n\ncurl -i -X GET -H \"Content-Type: application/json\"  localhost:8080/api/contact/105\nHTTP/1.1 404\nX-Application-Context: application:development\nContent-Type: text/html;charset=utf-8\nContent-Language: en-US\nContent-Length: 990\nDate: Mon, 31 Jul 2017 12:34:06 GMT\n\n\nApache Tomcat/8.5.5 - Error report", 
            "title": "Grails OOB(out of the box)"
        }, 
        {
            "location": "/tutorial/stock/#getting-started", 
            "text": "For this tutorial you will need    JDK (I advise 8, but you can take 7 as well).    Git.    Grails 3.2.11 (you can install it with  http://sdkman.io  on most Unix based systems.)    After all is installed clone the repo:  git clone https://github.com/9ci/angle-grinder  and switch to branch  rest_tutorial  branch, and go to  angle-grinder/grails/restTutorial , the final result is in\nthe  snapshot  folder for each step  So first let's create new grails app:  $ grails create-app -profile rest-api -features hibernate4 resttutorail\nApplication created at angle-grinder/grails/restTutorial  Grails 3 provides several different profiles you can read about them in the  grails docs", 
            "title": "Getting started"
        }, 
        {
            "location": "/tutorial/stock/#creating-an-api-with-grails-web-services", 
            "text": "As described in the  grails ws docs \nwe will use the default out of the box functionality as a starting point.", 
            "title": "Creating an API with Grails Web Services"
        }, 
        {
            "location": "/tutorial/stock/#creating-a-gorm-domain", 
            "text": "grails create-domain-class Contact  Then set it up like so:  Contact.groovy  package   resttutorial  class   Contact   { \n   String   firstName \n   String   lastName \n   String   email \n   Boolean   inactive \n\n   static   constraints   =   { \n     firstName   nullable:   false \n     inactive   bindable:   false \n   }  }   To avoid writing  nullable: true  we will set the default to allow nulls for fields\nAdd the following to  grails-app/conf/application.groovy  application.groovy  grails . gorm . default . constraints   =   { \n   *   ( nullable:   true ,   blank:   true )  }   We will load 100 rows of mock test data from a file  Contacts.json  in resources.\nThe mock data was generated from a great tool  https://www.mockaroo.com  Add the following code to  grails-app/init/BootStrap.groovy  BootStrap.groovy  package   resttutorial  import   groovy.json.JsonSlurper  class   BootStrap   { \n     def   grailsApplication \n     def   init   =   {   servletContext   - \n         def   data   =   new   JsonSlurper (). parse ( new   File ( ../resources/Contacts.json )) \n         data . each { \n           Contact   contact   =   new   Contact ( it ) \n           contact . save ( failOnError: true , flush:   true ) \n         } \n     } \n     def   destroy   =   { \n     }  }", 
            "title": "Creating a GORM domain"
        }, 
        {
            "location": "/tutorial/stock/#adding-the-resource-annotation-to-our-domain", 
            "text": ":url-dr: {docs-grails}#domainResources  So now we can start working on creating REST Api for our app.\nThe easiest way is to use {url-dr}[domain resources].\nSo as we see from {url-dr}[docs] we just need to update our domain a bit (just add {docs-grails-api}/grails/rest/Resource.html[@Resource] anotation) in such a way:  Contact.groovy  import   grails.rest.Resource  @Resource ( uri   =   /contact ,   formats   =   [ json ])  class   Contact   { \n   ...  }    :memo  On plural resource names \nAs you will notice we did not pluralize it to contacts above as many will do.\nWe are aware of the debate on this in the rest world. We feel this will cause confusion down the line to do it.   English plural rules like \"cherry/cherries\" or \"goose/geese/moose/meese\" are not the nicest thing to think of while developing API, particularly when english is not your mother tongue.  Many times, as in Grails, we want to generate endpoint from the model, which is usually singular. It does not play nicely with the above pluralization exceptions and creates more work maintaining UrlMappings.  When the model is singular, which is normally is for us, keeping the rest endpoint singular will have the rest developers and the grails developers speaking the same language  The argument \"usually you start querying by a Get to display a list\" does not refer to any real use case. And we will end up querying single items as much as and even more than a list of items.", 
            "title": "Adding the @Resource annotation to our domain"
        }, 
        {
            "location": "/tutorial/stock/#the-restfullcontroller", 
            "text": "@Resource  creates a RestfullController for the domain     The  @Resource  annotation \nis used in an ASTTransformation that creates a controller that extends RestfullController. See  ResourceTransform  for details on how it does this. Later we will show how to specify the controller to user with superClass property.", 
            "title": "The RestfullController"
        }, 
        {
            "location": "/tutorial/stock/#default-endpoints-and-status-codes", 
            "text": "", 
            "title": "Default Endpoints and Status Codes"
        }, 
        {
            "location": "/tutorial/stock/#url-mappings", 
            "text": "The  Extending Restful Controllers  section of the  grails docs  outlines the action names and the URIs they map to:  .URI, Controller Action and Response Defaults\n[cols=\"2,1,1,3\", format=\"csv\", options=\"header\", width=\"80\",grid=rows]\n|===\nURI, Method, Action, Response Data\n/contact , GET , index , Paged List\n/contact/create, GET , create , Contact.newInstance() unsaved\n/contact, POST , save , The successfully saved contact (same as show's get)\n/contact/ \\({id}, GET , show , The contact for the id\n/contact/\\) /edit, GET , edit , The contact for the id. same as show\n/contact/ \\({id}, PUT , update , The successfully updated contact\n/contact/\\) , DELETE , delete , Empty response with HTTP status code 204\n|===  ==== Status Code Defaults  Piecing together the {docs-HttpStatus}[HttpStatus codes] and results from RestfullController, RestResponder and _errors.gson,\nthese are what looks like the out of the box status codes as of Grails 3.2.2  .Status Codes Out Of Box\n[options=\"header\", cols=\"1,2\", grid=rows]\n|===\n| Status Code               | Description\n| 200 - OK                  | Everything worked as expected. default\n| 201 - CREATED             | Resource/instance was created. returned from  save  action\n| 204 - NO_CONTENT          | response code on successful DELETE request\n| 404 - NOT_FOUND           | The requested resource doesn't exist.\n| 405 - METHOD_NOT_ALLOWED  | If method (GET,POST,etc..) is not setup in  static allowedMethods  for action or resource is read only\n| 406 - NOT_ACCEPTABLE      | Accept header requests a response in an unsupported format. not configed in mime-types. RestResponder uses this\n| 422 - UNPROCESSABLE_ENTITY | Validation errors.\n|===  === API Namespace  A Namespace is a mechanism to partition resources into a logically named group.  So the controllers that response for the REST endpoints we will move to separate namespace to avoid cases when we need to\nhave Controllers for GSP rendering or some other not related to REST stuff.  As a our preferred namespace design we will use the \"api\" namespace prefix for the rest of the tutorial.\nSo we will add  namespace = 'api'  on the contact @Resource. @Resource has also property  uri  but it will override namespace property,\nfor example if @Resource(namespace = 'api', uri='contacts', formats = [\"json\"]) url for resource will be  localhost:8080/contacts , not  .Contact.groovy @Resource ( namespace   =   api ,   formats   =   [ json ])  class   Contact   Also we need to update UrlMappings.groovy, there are two ways:   Add  /api  prefix to each mapping for example   get  /api/$controller(.$format)? (action: index )  Use  group  property   We will use the second case:  .UrlMappings.groovy package   resttutorial  class   UrlMappings   { \n\n     static   mappings   =   { \n       group ( /api )   { \n         delete   /$controller/$id(.$format)? ( action: delete ) \n         get   /$controller(.$format)? ( action: index ) \n         get   /$controller/$id(.$format)? ( action: show ) \n         post   /$controller(.$format)? ( action: save ) \n         put   /$controller/$id(.$format)? ( action: update ) \n         patch   /$controller/$id(.$format)? ( action: patch ) \n       } \n         ... \n     }  }   You can see all available endpoints that Grails create for us with url-mappings-report:   $ grails url-mappings-report\n[options=\"header\", cols=\"1,2\", grid=rows]\nDynamic Mappings\n |    *     | ERROR: 500                                | View:   /error           |\n |    *     | ERROR: 404                                | View:   /notFound        |\n |   GET    | /api/ \\({controller}(.\\) {format)?            | Action: index            |\n |   POST   | /api/ \\({controller}(.\\) {format)?            | Action: save             |\n |  DELETE  | /api/ \\({controller}/\\) (. \\({format)?      | Action: delete           |\n |   GET    | /api/\\) / \\({id}(.\\) {format)?      | Action: show             |\n |   PUT    | /api/ \\({controller}/\\) (. \\({format)?      | Action: update           |\n |  PATCH   | /api/\\) / \\({id}(.\\) {format)?      | Action: patch            |  Controller: application\n |    *     | /                                                  | Action: index            |  Controller: contact\n |   GET    | /api/contact/create                                | Action: create           |\n |   GET    | /api/contact/ \\({id}/edit                            | Action: edit             |\n |   POST   | /api/contact                                       | Action: save             |\n |   GET    | /api/contact                                       | Action: index            |\n |  DELETE  | /api/contact/\\)                                  | Action: delete           |\n |  PATCH   | /api/contact/ \\({id}                                 | Action: patch            |\n |   PUT    | /api/contact/\\)                                  | Action: update           |\n |   GET    | /api/contact/${id}                                 | Action: show             |   === Using CURL to test CRUD and List  Fire up the app with  run-app", 
            "title": "Url Mappings"
        }, 
        {
            "location": "/tutorial/stock/#get-list", 
            "text": "curl -i -X GET -H \"Content-Type: application/json\"  localhost:8080/api/contact\nHTTP/1.1 200\nX-Application-Context: application:development\nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:30:31 GMT", 
            "title": "===== GET (list):"
        }, 
        {
            "location": "/tutorial/stock/#id1emailamp109amp115amp99amp111amp116amp116amp48amp64amp97amp109amp101amp98amp108amp111amp46amp106amp112firstnamemarielastnamescottid2emailamp106amp114amp111amp100amp114amp105amp103amp117amp101amp122amp49amp64amp115amp99amp114amp105amp98amp100amp46amp99amp111amp109firstnamejosephlastnamerodriguez", 
            "text": "", 
            "title": "[{\"id\":1,\"email\":\"&#109;&#115;&#99;&#111;&#116;&#116;&#48;&#64;&#97;&#109;&#101;&#98;&#108;&#111;&#46;&#106;&#112;\",\"firstName\":\"Marie\",\"lastName\":\"Scott\"},{\"id\":2,\"email\":\"&#106;&#114;&#111;&#100;&#114;&#105;&#103;&#117;&#101;&#122;&#49;&#64;&#115;&#99;&#114;&#105;&#98;&#100;&#46;&#99;&#111;&#109;\",\"firstName\":\"Joseph\",\"lastName\":\"Rodriguez\"}, ..."
        }, 
        {
            "location": "/tutorial/stock/#post", 
            "text": "curl -i -X POST -H \"Content-Type: application/json\" -d '{\"firstName\":\"Joe\", \"lastName\": \"Cool\"}' localhost:8080/api/contact\nHTTP/1.1 201\nX-Application-Context: application:development\nLocation:  http://localhost:8080/api/contact/101 \nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:30:44 GMT", 
            "title": "===== POST:"
        }, 
        {
            "location": "/tutorial/stock/#id101firstnamejoelastnamecool", 
            "text": "", 
            "title": "{\"id\":101,\"firstName\":\"Joe\",\"lastName\":\"Cool\"}"
        }, 
        {
            "location": "/tutorial/stock/#get-by-id", 
            "text": "curl -i -X GET -H \"Content-Type: application/json\"  localhost:8080/api/contact/101\nHTTP/1.1 200\nX-Application-Context: application:development\nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:31:00 GMT", 
            "title": "===== GET (by id):"
        }, 
        {
            "location": "/tutorial/stock/#id101firstnamejoelastnamecool_1", 
            "text": "", 
            "title": "{\"id\":101,\"firstName\":\"Joe\",\"lastName\":\"Cool\"}"
        }, 
        {
            "location": "/tutorial/stock/#put", 
            "text": "curl -i -X PUT -H \"Content-Type: application/json\" -d '{\"firstName\": \"New Name\", \"lastName\": \"New Last name\"}' localhost:8080/api/contact/101\nHTTP/1.1 200\nX-Application-Context: application:development\nLocation:  http://localhost:8080/api/contact/101 \nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:32:01 GMT", 
            "title": "===== PUT:"
        }, 
        {
            "location": "/tutorial/stock/#id101firstnamenew-namelastnamenew-last-name", 
            "text": "", 
            "title": "{\"id\":101,\"firstName\":\"New Name\",\"lastName\":\"New Last name\"}"
        }, 
        {
            "location": "/tutorial/stock/#delete", 
            "text": "curl -i -X DELETE -H \"Content-Type: application/json\"  localhost:8080/api/contact/50\nHTTP/1.1 204\nX-Application-Context: application:development\nDate: Mon, 31 Jul 2017 12:32:24 GMT", 
            "title": "===== DELETE:"
        }, 
        {
            "location": "/tutorial/stock/#422-post-validation-error", 
            "text": "curl -i -X POST -H \"Content-Type: application/json\" -d '{\"lastName\": \"Cool\"}' localhost:8080/api/contact\nHTTP/1.1 422\nX-Application-Context: application:development\nContent-Type: application/json;charset=UTF-8\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:32:41 GMT", 
            "title": "===== 422 - Post Validation Error:"
        }, 
        {
            "location": "/tutorial/stock/#messageproperty-firstname-of-class-class-resttutorialcontact-cannot-be-nullpathcontactindex_linksselfhrefhttplocalhost8080contactindex", 
            "text": "", 
            "title": "{\"message\":\"Property [firstName] of class [class resttutorial.Contact] cannot be null\",\"path\":\"/contact/index\",\"_links\":{\"self\":{\"href\":\"http://localhost:8080/contact/index\"}}}"
        }, 
        {
            "location": "/tutorial/stock/#404-get-error", 
            "text": "curl -i -X GET -H \"Content-Type: application/json\"  localhost:8080/api/contact/105\nHTTP/1.1 404\nX-Application-Context: application:development\nContent-Type: application/json;charset=UTF-8\nContent-Language: en-US\nTransfer-Encoding: chunked\nDate: Mon, 31 Jul 2017 12:32:55 GMT", 
            "title": "===== 404 - Get Error:"
        }, 
        {
            "location": "/tutorial/stock/#messagenot-founderror404", 
            "text": "===== 406 - NOT_ACCEPTABLE:", 
            "title": "{\"message\":\"Not Found\",\"error\":404}"
        }, 
        {
            "location": "/tutorial/stock/#we-did-not-setup-xml-support-so-we-will-get-a-406-you-may-try-adding-xml-to-formats-to-see-if-this", 
            "text": "curl -i -X GET -H \"Accept: application/xml\"   http://localhost:8080/api/contact/8 \nHTTP/1.1 406\nX-Application-Context: application:development\nContent-Length: 0\nDate: Mon, 31 Jul 2017 12:33:13 GMT   === Functional Tests for the API  The next step is to add functional tests for our app. One option is to use Grails functional tests and RestBuilder.\nWe will cover another javscript option later the angle-grinder section\nThe line in the buidl.gradle that allows us to use RestBuilder is", 
            "title": "We did not setup XML support so we will get a 406. You may try adding XML to formats to see if this."
        }, 
        {
            "location": "/tutorial/stock/#testcompile-orggrailsgrails-datastore-rest-client", 
            "text": "it is added by default when you create a grails app with  -profile rest-api  ==== POST testing example  Here is an example of  POST  request (creating of a new contact).\nRestBuilder we use to emulate request from external source. Note, in Grails3 integration tests run on the random port,\nso you cant call  http://localhost:8080/api/contact  , but we can use  serverPort  variable instead. And to make it more\nintelligent lets use baseUrl. See example:  .ContactSpec.groovy package   resttutorial  import   grails.plugins.rest.client.RestBuilder  import   grails.plugins.rest.client.RestResponse  import   grails.test.mixin.integration.Integration  import   org.grails.web.json.JSONElement  import   spock.lang.Shared  import   spock.lang.Specification  @Integration  class   ContactSpec   extends   Specification   { \n\n     @Shared \n     RestBuilder   rest   =   new   RestBuilder () \n\n     def   getBaseUrl (){ http://localhost:${serverPort}/api } \n\n     void   check POST request ()   { \n         when: \n         RestResponse   response   =   rest . post ( ${baseUrl}/contact ){ \n           json ([ \n             firstName:   Test contact , \n             email: foo@bar.com , \n             inactive: true   //is bindable: false - see domain, so it wont be set to contact \n           ]) \n         } \n\n         then: \n         response . status   ==   201 \n         JSONElement   json   =   response . json \n         json . id   ==   101 \n         json . firstName   ==   Test contact \n         json . lastName   ==   null \n         json . email   ==   foo@bar.com \n         json . inactive   ==   null \n     }  }   More tests examples are in the snapshot1 project's\n{url-snapshot1}/src/integration-test/groovy/resttutorial/ContactSpec.groovy[ContactSpec.groovy]  === GSON and Grails Views Defaults  As you can see by inspecting the views directory, by default Grails creates a number of gson files. Support for them is\nprovided with  http://views.grails.org/latest/#_introduction[Grails  Views Plugin]  The obvious question how does it work. If you look at sources of the RestfullController it doesn't \"call\" this templates\nexplicitly. So under the hood plugin just looks on request, if url ends on  .json (localhost:8080/api/contact/1.json) or if Accept  header containing  application/json  the .gson view will be rendered.  If you delete default generated templates, then it will show default Grails page. Go ahead and try to delete  notFound.gson \nand try   curl -i -X GET -H \"Content-Type: application/json\"  localhost:8080/api/contact/105\nHTTP/1.1 404\nX-Application-Context: application:development\nContent-Type: text/html;charset=utf-8\nContent-Language: en-US\nContent-Length: 990\nDate: Mon, 31 Jul 2017 12:34:06 GMT  Apache Tomcat/8.5.5 - Error report", 
            "title": "testCompile \"org.grails:grails-datastore-rest-client\""
        }, 
        {
            "location": "/glossary/", 
            "text": "**a dunping ground for random notes and thoughts right now **\n\n\nrefs\ngood read\n\nhttps://medium.com/@stschindler/5-rules-that-help-you-build-more-awesome-rest-apis-179f90844f4f\n\n\non docs\n\nhttps://bradfults.com/the-best-api-documentation-b9e46400379a\n\n\nwe should implement \nhttp://jsonpatch.com/\n this for grails\n\n\nAST Ideas\n\n\nhow to do Global Transform to add annotations to classes that have annotations\n\nhttps://stackoverflow.com/questions/35834750/missing-ast-classes-in-global-transform", 
            "title": "Glossary"
        }, 
        {
            "location": "/glossary/#ast-ideas", 
            "text": "how to do Global Transform to add annotations to classes that have annotations https://stackoverflow.com/questions/35834750/missing-ast-classes-in-global-transform", 
            "title": "AST Ideas"
        }
    ]
}